#include "pch.h"
#include <complex>
#include "vidf/common/intersect.h"
#include "vidf/proto/text.h"
#include "brofiler.h"

#if 0

using namespace vidf;
using namespace proto;


// #define SYNTH_SUPERSAMPLE


namespace
{


// https://www.ebayinc.com/stories/blogs/tech/fast-approximate-logarithms-part-i-the-basics/
inline float fastlog2(float x)  // compute log2(x) by reducing x to [0.75, 1.5)
{
    // a*(x-1)^2 + b*(x-1) approximates log2(x) when 0.75 <= x < 1.5
    const float a =  -.6296735;
    const float b =   1.466967;
    float signif, fexp;
    int exp;
    float lg2;
    union { float f; unsigned int i; } ux1, ux2;
    int greater; // really a boolean 
    /* 
     * Assume IEEE representation, which is sgn(1):exp(8):frac(23)
     * representing (1+frac)*2^(exp-127)  Call 1+frac the significand
     */

    // get exponent
    ux1.f = x;
    exp = (ux1.i & 0x7F800000) >> 23; 
    // actual exponent is exp-127, will subtract 127 later

    greater = ux1.i & 0x00400000;  // true if signif > 1.5
    if (greater) {
        // signif >= 1.5 so need to divide by 2.  Accomplish this by 
        // stuffing exp = 126 which corresponds to an exponent of -1 
        ux2.i = (ux1.i & 0x007FFFFF) | 0x3f000000;
        signif = ux2.f;
        fexp = exp - 126;    // 126 instead of 127 compensates for division by 2
        signif = signif - 1.0;                    // <
        lg2 = fexp + a*signif*signif + b*signif;  // <
    } else {
        // get signif by stuffing exp = 127 which corresponds to an exponent of 0
        ux2.i = (ux1.i & 0x007FFFFF) | 0x3f800000;
        signif = ux2.f;
        fexp = exp - 127;
        signif = signif - 1.0;                    // <<--
        lg2 = fexp + a*signif*signif + b*signif;  // <<--
    }
    // lines marked <<-- are common code, but optimize better 
    //  when duplicated, at least when using gcc
    return(lg2);
}



template<typename T>
T Sigmoid(T x)
{
	return std::exp(x) / (std::exp(x) + T(1.0));
}


}


namespace vcv
{


	template <typename T, size_t S>
	struct floatRingBuffer
	{
		T data[S * 2];
		size_t start = 0;
		size_t end = 0;

		size_t mask(size_t i) const
		{
			return i & (S - 1);
		}
		void push(T t)
		{
			size_t i = mask(end++);
			data[i] = t;
			data[i + S] = t;
		}
		T shift()
		{
			return data[mask(start++)];
		}
		void clear()
		{
			start = end;
		}
		bool empty() const
		{
			return start == end;
		}
		bool full() const
		{
			return end - start == S;
		}
		size_t size() const
		{
			return end - start;
		}
		size_t capacity() const
		{
			return S - size();
		}
		/** Returns a pointer to S consecutive elements for appending.
		If any data is appended, you must call endIncr afterwards.
		Pointer is invalidated when any other method is called.
		*/
		T *endData()
		{
			return &data[mask(end)];
		}
		void endIncr(size_t n)
		{
			size_t e = mask(end);
			size_t e1 = e + n;
			size_t e2 = (e1 < S) ? e1 : S;
			// Copy data forward
			memcpy(&data[S + e], &data[e], sizeof(T) * (e2 - e));

			if (e1 > S) {
				// Copy data backward from the floatd block to the main block
				memcpy(data, &data[S], sizeof(T) * (e1 - S));
			}
			end += n;
		}
		/** Returns a pointer to S consecutive elements for consumption
		If any data is consumed, call startIncr afterwards.
		*/
		const T *startData() const
		{
			return &data[mask(start)];
		}
		void startIncr(size_t n)
		{
			start += n;
		}
	};


	inline float sinc(float x)
	{
		if (x == 0.0)
			return 1.0;
		x *= PI;
		return std::sin(x) / x;
	}


	inline float convolve(const float* x, const float* kernel, int len)
	{
		float y = 0.0;
		for (int i = 0; i < len; i++)
			y += x[-i] * kernel[i];
		return y;
	}


	inline void blackmanHarrisWindow(float* x, int n)
	{
		const float a0 = 0.35875;
		const float a1 = 0.48829;
		const float a2 = 0.14128;
		const float a3 = 0.01168;
		for (int i = 0; i < n; i++)
		{
			x[i] *= a0
				- a1 * std::cos(2 * PI * i / (n - 1))
				+ a2 * std::cos(4 * PI * i / (n - 1))
				- a3 * std::cos(6 * PI * i / (n - 1));
		}
	}


	inline void boxcarFIR(float* x, int n, float cutoff)
	{
		for (int i = 0; i < n; i++)
		{
			float t = (float)i / (n - 1) * 2.0 - 1.0;
			x[i] = sinc(t * n * cutoff);
		}
	}


	template<int OVERSAMPLE, int QUALITY>
	struct Decimator
	{
		floatRingBuffer<float, OVERSAMPLE * QUALITY> inBuffer;
		float kernel[OVERSAMPLE * QUALITY];

		Decimator(float cutoff = 0.9)
		{
			boxcarFIR(kernel, OVERSAMPLE * QUALITY, cutoff * 0.5 / OVERSAMPLE);
			blackmanHarrisWindow(kernel, OVERSAMPLE * QUALITY);
			// The sum of the kernel should be 1
			float sum = 0.0;
			for (int i = 0; i < OVERSAMPLE*QUALITY; i++)
				sum += kernel[i];
			for (int i = 0; i < OVERSAMPLE*QUALITY; i++)
				kernel[i] /= sum;
			// Zero input buffer
			memset(inBuffer.data, 0, sizeof(inBuffer.data));
		}

		/** `in` must be OVERSAMPLE floats long */
		float process(float* in)
		{
			memcpy(inBuffer.endData(), in, OVERSAMPLE * sizeof(float));
			inBuffer.endIncr(OVERSAMPLE);
			float out = convolve(inBuffer.endData() + OVERSAMPLE * QUALITY, kernel, OVERSAMPLE * QUALITY);
			// Ignore the ring buffer's start position
			return out;
		}
	};



	inline float interpolateLinear(const float *p, float x)
	{
		int xi = x;
		float xf = x - xi;
		return Lerp(p[xi], p[xi + 1], xf);
	}


	const float minblep_16_32[] =
	{
		0.00011023, 0.00022416, 0.00034297, 0.00046661, 0.00059353, 0.00072403, 0.00085807, 0.00099544, 0.00113669, 0.00128244, 0.00143357, 0.00159180, 0.00175889, 0.00193681, 0.00212798, 0.00233618, 0.00256460, 0.00281804, 0.00310111, 0.00341981, 0.00378001, 0.00418855, 0.00465331, 0.00518249, 0.00578578, 0.00647247, 0.00725390, 0.00814134, 0.00914690, 0.01028436, 0.01156735, 0.01301055, 0.01462957, 0.01644073, 0.01846137, 0.02070885, 0.02320160, 0.02595890, 0.02900020, 0.03234551, 0.03601537, 0.04003051, 0.04441243, 0.04918219, 0.05436156, 0.05997159, 0.06603400, 0.07256979, 0.07960004, 0.08714473, 0.09522393, 0.10385663, 0.11306075, 0.12285375, 0.13325208, 0.14427035, 0.15592176, 0.16821821, 0.18117011, 0.19478568, 0.20907153, 0.22403158, 0.23966792, 0.25598019, 0.27296567, 0.29061884, 0.30893153, 0.32789305, 0.34748974, 0.36770493, 0.38851914, 0.40990984, 0.43185139, 0.45431516, 0.47726974, 0.50068015, 0.52450907, 0.54871643, 0.57325858, 0.59809023, 0.62316221, 0.64842403, 0.67382252, 0.69930243, 0.72480643, 0.75027585, 0.77565008, 0.80086774, 0.82586610, 0.85058230, 0.87495226, 0.89891225, 0.92239881, 0.94534874, 0.96769959, 0.98939002, 1.01036096, 1.03055346, 1.04991257, 1.06838441, 1.08591819, 1.10246634, 1.11798477, 1.13243258, 1.14577281, 1.15797329, 1.16900539, 1.17884552, 1.18747461, 1.19487906, 1.20105016, 1.20598388, 1.20968246, 1.21215260, 1.21340692, 1.21346366, 1.21234596, 1.21008229, 1.20670640, 1.20225751, 1.19677913, 1.19032025, 1.18293369, 1.17467666, 1.16561043, 1.15579987, 1.14531350, 1.13422263, 1.12260056, 1.11052382, 1.09806967, 1.08531761, 1.07234740, 1.05923963, 1.04607463, 1.03293216, 1.01989150, 1.00703001, 0.99442369, 0.98214602, 0.97026730, 0.95885533, 0.94797397, 0.93768352, 0.92803955, 0.91909295, 0.91089052, 0.90347338, 0.89687651, 0.89113057, 0.88625956, 0.88228178, 0.87920940, 0.87704903, 0.87580091, 0.87545884, 0.87601125, 0.87744081, 0.87972385, 0.88283205, 0.88673097, 0.89138156, 0.89674008, 0.90275854, 0.90938461, 0.91656262, 0.92423326, 0.93233514, 0.94080383, 0.94957352, 0.95857650, 0.96774524, 0.97700989, 0.98630202, 0.99555433, 1.00469887, 1.01367104, 1.02240634, 1.03084445, 1.03892660, 1.04659796, 1.05380774, 1.06050789, 1.06665611, 1.07221341, 1.07714641, 1.08142638, 1.08503044, 1.08793986, 1.09014225, 1.09163105, 1.09240448, 1.09246624, 1.09182608, 1.09049749, 1.08850145, 1.08586180, 1.08260751, 1.07877254, 1.07439494, 1.06951582, 1.06418049, 1.05843639, 1.05233502, 1.04592884, 1.03927267, 1.03242254, 1.02543569, 1.01836896, 1.01127994, 1.00422585, 0.99726236, 0.99044448, 0.98382431, 0.97745323, 0.97137886, 0.96564668, 0.96029860, 0.95537275, 0.95090336, 0.94692129, 0.94345307, 0.94051903, 0.93813735, 0.93632013, 0.93507481, 0.93440408, 0.93430620, 0.93477470, 0.93579876, 0.93736202, 0.93944514, 0.94202399, 0.94507092, 0.94855475, 0.95244062, 0.95669132, 0.96126628, 0.96612370, 0.97121888, 0.97650659, 0.98193920, 0.98746979, 0.99305087, 0.99863440, 1.00417352, 1.00962198, 1.01493454, 1.02006841, 1.02498233, 1.02963722, 1.03399694, 1.03802824, 1.04170084, 1.04498816, 1.04786694, 1.05031765, 1.05232465, 1.05387664, 1.05496621, 1.05558980, 1.05574775, 1.05544484, 1.05468917, 1.05349278, 1.05187225, 1.04984665, 1.04743862, 1.04467380, 1.04158032, 1.03818953, 1.03453457, 1.03065002, 1.02657270, 1.02234089, 1.01799285, 1.01356828, 1.00910676, 1.00464690, 1.00022852, 0.99588913, 0.99166596, 0.98759449, 0.98370826, 0.98003900, 0.97661632, 0.97346693, 0.97061497, 0.96808159, 0.96588528, 0.96404094, 0.96256018, 0.96145141, 0.96072024, 0.96036756, 0.96039182, 0.96078801, 0.96154761, 0.96265966, 0.96410930, 0.96587980, 0.96795046, 0.97029966, 0.97290313, 0.97573400, 0.97876412, 0.98196387, 0.98530257, 0.98874873, 0.99227041, 0.99583501, 0.99940956, 1.00296247, 1.00646222, 1.00987804, 1.01318014, 1.01634085, 1.01933396, 1.02213407, 1.02471924, 1.02706873, 1.02916455, 1.03099120, 1.03253567, 1.03378832, 1.03474081, 1.03538895, 1.03573155, 1.03576887, 1.03550470, 1.03494596, 1.03410137, 1.03298199, 1.03160226, 1.02997768, 1.02812684, 1.02606928, 1.02382588, 1.02142048, 1.01887643, 1.01621914, 1.01347411, 1.01066744, 1.00782573, 1.00497484, 1.00214148, 0.99935061, 0.99662775, 0.99399650, 0.99147928, 0.98909825, 0.98687279, 0.98482132, 0.98295969, 0.98130250, 0.97986293, 0.97865003, 0.97767186, 0.97693449, 0.97644144, 0.97619355, 0.97618985, 0.97642678, 0.97689945, 0.97759926, 0.97851688, 0.97964054, 0.98095751, 0.98245293, 0.98410982, 0.98591143, 0.98783875, 0.98987180, 0.99199086, 0.99417531, 0.99640393, 0.99865520, 1.00090814, 1.00314200, 1.00533652, 1.00747168, 1.00952899, 1.01149011, 1.01333869, 1.01505876, 1.01663721, 1.01806092, 1.01931858, 1.02040136, 1.02130210, 1.02201474, 1.02253604, 1.02286315, 1.02299595, 1.02293634, 1.02268875, 1.02225709, 1.02164853, 1.02087140, 1.01993537, 1.01885104, 1.01763213, 1.01629102, 1.01484251, 1.01330113, 1.01168346, 1.01000535, 1.00828362, 1.00653470, 1.00477552, 1.00302279, 1.00129271, 0.99960083, 0.99796313, 0.99639338, 0.99490535, 0.99351192, 0.99222440, 0.99105316, 0.99000835, 0.98909634, 0.98832458, 0.98769748, 0.98721880, 0.98689038, 0.98671335, 0.98668671, 0.98680866, 0.98707467, 0.98748106, 0.98802143, 0.98868805, 0.98947275, 0.99036646, 0.99135911, 0.99243897, 0.99359548, 0.99481559, 0.99608690, 0.99739677, 0.99873203, 1.00007975, 1.00142658, 1.00276041, 1.00406802, 1.00533855, 1.00655985, 1.00772119, 1.00881267, 1.00982487, 1.01075006, 1.01158035, 1.01230979, 1.01293266, 1.01344562, 1.01384568, 1.01412964, 1.01429844, 1.01435149, 1.01429081, 1.01411796, 1.01383793, 1.01345396, 1.01297212, 1.01239896, 1.01174057, 1.01100540, 1.01020169, 1.00933838, 1.00842452, 1.00746989, 1.00648463, 1.00547814, 1.00446069, 1.00344217, 1.00243223, 1.00143993, 1.00047517, 0.99954665, 0.99866235, 0.99782991, 0.99705631, 0.99634796, 0.99571103, 0.99514896, 0.99466711, 0.99426842, 0.99395454, 0.99372780, 0.99358785, 0.99353504, 0.99356812, 0.99368507, 0.99388355, 0.99415958, 0.99450946, 0.99492884, 0.99541146, 0.99595195, 0.99654400, 0.99718058, 0.99785507, 0.99856061, 0.99928933, 1.00003409, 1.00078654, 1.00154030, 1.00228751, 1.00302088, 1.00373411, 1.00442064, 1.00507402, 1.00568807, 1.00625861, 1.00678062, 1.00724947, 1.00766242, 1.00801611, 1.00830781, 1.00853622, 1.00870037, 1.00880003, 1.00883472, 1.00880599, 1.00871444, 1.00856256, 1.00835276, 1.00808787, 1.00777161, 1.00740683, 1.00699902, 1.00655174, 1.00606918, 1.00555754, 1.00502074, 1.00446463, 1.00389385, 1.00331378, 1.00272894, 1.00214446, 1.00156450, 1.00099480, 1.00043809, 0.99989861, 0.99938035, 0.99888563, 0.99841738, 0.99797773, 0.99756885, 0.99719167, 0.99684638, 0.99653435, 0.99625492, 0.99600822, 0.99579257, 0.99560666, 0.99544859, 0.99531645, 0.99520802, 0.99512035, 0.99504977, 0.99499327, 0.99494720, 0.99490863, 0.99487358, 0.99483842, 0.99479860, 0.99475139, 0.99469274, 0.99461985, 0.99452943, 0.99441826, 0.99428391, 0.99412394, 0.99393618, 0.99371916, 0.99347186, 0.99319351, 0.99288350, 0.99254173, 0.99216926, 0.99176681, 0.99133593, 0.99087846, 0.99039710, 0.98989451, 0.98937410, 0.98883879, 0.98829341, 0.98774183, 0.98718870, 0.98663867, 0.98609704, 0.98556888, 0.98505920, 0.98457366, 0.98411739, 0.98369551, 0.98331392, 0.98297703, 0.98268992, 0.98245704, 0.98228276, 0.98217118, 0.98212564, 0.98214996, 0.98224646, 0.98241693, 0.98266387, 0.98298812, 0.98339027, 0.98387039, 0.98442757, 0.98506147, 0.98577005, 0.98655069, 0.98740059, 0.98831660, 0.98929417, 0.99032903, 0.99141610, 0.99254966, 0.99372399, 0.99493235, 0.99616790, 0.99742448, 0.99869454, 0.99997079, 1.00124514, 1.00251019, 1.00375855, 1.00498211, 1.00617325, 1.00732577, 1.00843060, 1.00948179, 1.01047242, 1.01139629, 1.01224756, 1.01302052, 1.01371098, 1.01431394, 1.01482534, 1.01524329, 1.01556420, 1.01578641, 1.01590872, 1.01593041, 1.01585221, 1.01567483, 1.01539934, 1.01502872, 1.01456475, 1.01401234, 1.01337564, 1.01265824, 1.01186681, 1.01100624, 1.01008308, 1.00910449, 1.00807726, 1.00700867, 1.00590730, 1.00478077, 1.00363719, 1.00248516, 1.00133204, 1.00018704, 0.99905777, 0.99795246, 0.99687880, 0.99584419, 0.99485654, 0.99392235, 0.99304855, 0.99224019, 0.99150354, 0.99084306, 0.99026269, 0.98976678, 0.98935860, 0.98903960, 0.98881179, 0.98867643, 0.98863405, 0.98868364, 0.98882431, 0.98905468, 0.98937207, 0.98977262, 0.99025381, 0.99081081, 0.99143785, 0.99213088, 0.99288279, 0.99368858, 0.99454105, 0.99543440, 0.99635935, 0.99730903, 0.99827605, 0.99925363, 1.00023246, 1.00120509, 1.00216508, 1.00310433, 1.00401509, 1.00489199, 1.00572717, 1.00651467, 1.00724912, 1.00792384, 1.00853491, 1.00907779, 1.00954843, 1.00994480, 1.01026309, 1.01050198, 1.01066041, 1.01073647, 1.01073205, 1.01064730, 1.01048374, 1.01024330, 1.00992775, 1.00954151, 1.00908792, 1.00857103, 1.00799608, 1.00736785, 1.00669181, 1.00597465, 1.00522304, 1.00444114, 1.00363779, 1.00281966, 1.00199306, 1.00116563, 1.00034273, 0.99953192, 0.99873996, 0.99797446, 0.99724007, 0.99654233, 0.99588805, 0.99528110, 0.99472731, 0.99422991, 0.99379259, 0.99341941, 0.99311274, 0.99287349, 0.99270529, 0.99260652, 0.99257857, 0.99261945, 0.99273038, 0.99290955, 0.99315345, 0.99346066, 0.99382687, 0.99424839, 0.99472272, 0.99524361, 0.99580789, 0.99640882, 0.99704123, 0.99769914, 0.99837738, 0.99906975, 0.99976873, 1.00046957, 1.00116682, 1.00185359, 1.00252378, 1.00317132, 1.00379229, 1.00438106, 1.00493193, 1.00543988, 1.00590360, 1.00631797, 1.00667834, 1.00698411, 1.00723267, 1.00742185, 1.00755143, 1.00761986, 1.00762773, 1.00757504, 1.00746322, 1.00729394, 1.00706911, 1.00679159, 1.00646341, 1.00608873, 1.00567114, 1.00521481, 1.00472414, 1.00420344, 1.00365949, 1.00309455, 1.00251555, 1.00192726, 1.00133574, 1.00074565, 1.00016236, 0.99959171, 0.99903804, 0.99850535, 0.99799985, 0.99752414, 0.99708354, 0.99668151, 0.99632025, 0.99600381, 0.99573332, 0.99551266, 0.99534053, 0.99522054, 0.99515241, 0.99513555, 0.99517030, 0.99525541, 0.99538952, 0.99557215, 0.99579948, 0.99607027, 0.99638057, 0.99672699, 0.99710703, 0.99751633, 0.99795067, 0.99840581, 0.99887735, 0.99936110, 0.99985218, 1.00034654, 1.00083947, 1.00132573, 1.00180173, 1.00226319, 1.00270593, 1.00312614, 1.00351942, 1.00388277, 1.00421333, 1.00450921, 1.00476730, 1.00498581, 1.00516307, 1.00529838, 1.00539017, 1.00543821, 1.00544345, 1.00540483, 1.00532460, 1.00520289, 1.00504267, 1.00484514, 1.00461233, 1.00434721, 1.00405192, 1.00373054, 1.00338578, 1.00302088, 1.00264025, 1.00224662, 1.00184488, 1.00143826, 1.00103080, 1.00062573, 1.00022781, 0.99984139, 0.99946749, 0.99911129, 0.99877495, 0.99846184, 0.99817514, 0.99791592, 0.99768758, 0.99749118, 0.99732894, 0.99720013, 0.99710739, 0.99705017, 0.99702936, 0.99704379, 0.99709320, 0.99717599, 0.99729306, 0.99744141, 0.99761915, 0.99782479, 0.99805552, 0.99830848, 0.99858129, 0.99887139, 0.99917626, 0.99949169, 0.99981594, 1.00014460, 1.00047433, 1.00080299, 1.00112653, 1.00144279, 1.00174880, 1.00204086, 1.00231719, 1.00257576, 1.00281310, 1.00302708, 1.00321829, 1.00338340, 1.00352204, 1.00363243, 1.00371420, 1.00376749, 1.00379157, 1.00378597, 1.00375187, 1.00369036, 1.00360274, 1.00348926, 1.00335169, 1.00319159, 1.00301039, 1.00281143, 1.00259674, 1.00236738, 1.00212586, 1.00187516, 1.00161850, 1.00135744, 1.00109494, 1.00083435, 1.00057673, 1.00032485, 1.00008142, 0.99984884, 0.99962848, 0.99942255, 0.99923331, 0.99906200, 0.99890971, 0.99877805, 0.99866712, 0.99857920, 0.99851406, 0.99847245, 0.99845350, 0.99845672, 0.99848276, 0.99853104, 0.99859989, 0.99868929, 0.99879676, 0.99892145, 0.99906349, 0.99921906, 0.99938750, 0.99956673, 0.99975437, 0.99995005, 1.00015068, 1.00035346, 1.00055718, 1.00075948, 1.00095868, 1.00115299, 1.00134051, 1.00151980, 1.00168908, 1.00184536, 1.00198960, 1.00211966, 1.00223446, 1.00233328, 1.00241554, 1.00247967, 1.00252616, 1.00255466, 1.00256550, 1.00255883, 1.00253487, 1.00249410, 1.00243723, 1.00236428, 1.00227737, 1.00217772, 1.00206661, 1.00194490, 1.00181246, 1.00167227, 1.00152564, 1.00137448, 1.00121903, 1.00106311, 1.00090694, 1.00075161, 1.00059938, 1.00045121, 1.00030851, 1.00017321, 1.00004661, 0.99992871, 0.99982160, 0.99972528, 0.99964148, 0.99956852, 0.99950951, 0.99946433, 0.99943203, 0.99941361, 0.99940944, 0.99941790, 0.99943894, 0.99947232, 0.99951869, 0.99957561, 0.99964315, 0.99972034, 0.99980599, 0.99989998, 1.00000000,
	};


	template<int ZERO_CROSSINGS>
	struct MinBLEP
	{
		float buf[2 * ZERO_CROSSINGS] = {};
		int pos = 0;
		const float *minblep;
		int oversample;

		/** Places a discontinuity with magnitude dx at -1 < p <= 0 relative to the current frame */
		void jump(float p, float dx)
		{
			if (p <= -1 || 0 < p)
				return;
			for (int j = 0; j < 2 * ZERO_CROSSINGS; j++)
			{
				float minblepIndex = ((float)j - p) * oversample;
				int index = (pos + j) % (2 * ZERO_CROSSINGS);
				buf[index] += dx * (-1.0 + interpolateLinear(minblep, minblepIndex));
			}
		}
		float shift()
		{
			float v = buf[pos];
			buf[pos] = 0.0;
			pos = (pos + 1) % (2 * ZERO_CROSSINGS);
			return v;
		}
	};


	inline float FastAbs(float x)
	{
		union { float f; unsigned int i; } ux1;
		ux1.f = x;
		ux1.i &= 0x7fffffff;
		return ux1.f;
	}


	inline float FastTanh(float x)
	{
		const float maxX = 44.359375000000000f;
		if (FastAbs(x) < maxX)
			return Sigmoid(2.0f * x) * 2.0f - 1.0f;
		else
			return float(Sigmoid(2.0 * double(x))) * 2.0f - 1.0f;
	}


	inline float clip(float x)
	{
		// return tanhf(x);
		return FastTanh(x);
	}

	struct LadderFilter
	{
		float cutoff = 1000.0f;
		float resonance = 1.0f;
		float state[4] = {};

		void calculateDerivatives(float input, float *dstate, const float *state)
		{
			float cutoff2Pi = 2 * vidf::PI * cutoff;

			float satstate0 = clip(state[0]);
			float satstate1 = clip(state[1]);
			float satstate2 = clip(state[2]);

			dstate[0] = cutoff2Pi * (clip(input - resonance * state[3]) - satstate0);
			dstate[1] = cutoff2Pi * (satstate0 - satstate1);
			dstate[2] = cutoff2Pi * (satstate1 - satstate2);
			dstate[3] = cutoff2Pi * (satstate2 - clip(state[3]));
		}

		void process(float input, float dt)
		{
			float deriv1[4], deriv2[4], deriv3[4], deriv4[4], tempState[4];

			calculateDerivatives(input, deriv1, state);
			for (int i = 0; i < 4; i++)
				tempState[i] = state[i] + 0.5f * dt * deriv1[i];

			calculateDerivatives(input, deriv2, tempState);
			for (int i = 0; i < 4; i++)
				tempState[i] = state[i] + 0.5f * dt * deriv2[i];

			calculateDerivatives(input, deriv3, tempState);
			for (int i = 0; i < 4; i++)
				tempState[i] = state[i] + dt * deriv3[i];

			calculateDerivatives(input, deriv4, tempState);
			for (int i = 0; i < 4; i++)
				state[i] += (1.0f / 6.0f) * dt * (deriv1[i] + 2.0f * deriv2[i] + 2.0f * deriv3[i] + deriv4[i]);
		}
		void reset()
		{
			for (int i = 0; i < 4; i++)
			{
				state[i] = 0.0f;
			}
		}

	};



	std::array<float, 2048> sawTable =
	{
		-0.0525338, -0.124172, -0.201123, -0.28145, -0.361514, -0.437677, -0.506323, -0.565947, -0.61981, -0.668566, -0.712743, -0.752877, -0.789483, -0.821637, -0.849041, -0.872562, -0.893078, -0.911459, -0.928371, -0.94253, -0.953999, -0.963373, -0.971244, -0.978205, -0.984408, -0.988963, -0.992177, -0.994451, -0.996186, -0.997786, -0.999106, -0.999791, -1.0, -0.999892, -0.999627, -0.99935, -0.998924, -0.998293, -0.997489, -0.996544, -0.99549, -0.994324, -0.992938, -0.9914, -0.989797, -0.988217, -0.98675, -0.985459, -0.984295, -0.983177, -0.982026, -0.98076, -0.9793, -0.977576, -0.975661, -0.973667, -0.971707, -0.969891, -0.968331, -0.967043, -0.965911, -0.964815, -0.963632, -0.962241, -0.960532, -0.958548, -0.956417, -0.954273, -0.952245, -0.950466, -0.948995, -0.947739, -0.946587, -0.94543, -0.944156, -0.942662, -0.940966, -0.939147, -0.937271, -0.935407, -0.933622, -0.931964, -0.930389, -0.928864, -0.927356, -0.925834, -0.924266, -0.922637, -0.920969, -0.919284, -0.917603, -0.915947, -0.914338, -0.912774, -0.91124, -0.909724, -0.908215, -0.9067, -0.905174, -0.903657, -0.902144, -0.900623, -0.899085, -0.897519, -0.895907, -0.894246, -0.892562, -0.890886, -0.889245, -0.887668, -0.886183, -0.884763, -0.883367, -0.881952, -0.880476, -0.878893, -0.877185, -0.875402, -0.873605, -0.871856, -0.870213, -0.868734, -0.867403, -0.866151, -0.864909, -0.863607, -0.862175, -0.86057, -0.85884, -0.857056, -0.855289, -0.853607, -0.852081, -0.850725, -0.849477, -0.848268, -0.847031, -0.845696, -0.844208, -0.842597, -0.840914, -0.839205, -0.83752, -0.835907, -0.834385, -0.83292, -0.831484, -0.830055, -0.828605, -0.827111, -0.825575, -0.824013, -0.82244, -0.820868, -0.81931, -0.817777, -0.816267, -0.814769, -0.813273, -0.811771, -0.810251, -0.808705, -0.807134, -0.805552, -0.803974, -0.802414, -0.800886, -0.799393, -0.797924, -0.796471, -0.795025, -0.793575, -0.792118, -0.790676, -0.78924, -0.787798, -0.786332, -0.784828, -0.78326, -0.781618, -0.77994, -0.778267, -0.776639, -0.775098, -0.773676, -0.772344, -0.771056, -0.769763, -0.768417, -0.766973, -0.765427, -0.763815, -0.762179, -0.760556, -0.758986, -0.757505, -0.756108, -0.754755, -0.753405, -0.752018, -0.750554, -0.748967, -0.747275, -0.745539, -0.743822, -0.742186, -0.740694, -0.739378, -0.738183, -0.737041, -0.735882, -0.734639, -0.73325, -0.731736, -0.730147, -0.728531, -0.726936, -0.725409, -0.723977, -0.722606, -0.721272, -0.719951, -0.718621, -0.717259, -0.715868, -0.714464, -0.713052, -0.711638, -0.710226, -0.708824, -0.707431, -0.706042, -0.704652, -0.703255, -0.701847, -0.700422, -0.698983, -0.697535, -0.696081, -0.694629, -0.693182, -0.691736, -0.690286, -0.688838, -0.687396, -0.685967, -0.684557, -0.683176, -0.681815, -0.680459, -0.679094, -0.677703, -0.676271, -0.674794, -0.673291, -0.671787, -0.670306, -0.668872, -0.66751, -0.666213, -0.664942, -0.663664, -0.66234, -0.660935, -0.659418, -0.657823, -0.656203, -0.654607, -0.653087, -0.651693, -0.650422, -0.649228, -0.648061, -0.64687, -0.645608, -0.64424, -0.642798, -0.641314, -0.639821, -0.638352, -0.636938, -0.635586, -0.634273, -0.63298, -0.631688, -0.630378, -0.629033, -0.627661, -0.626273, -0.624876, -0.623477, -0.622085, -0.620705, -0.619334, -0.617966, -0.616596, -0.615218, -0.613827, -0.612416, -0.61099, -0.609555, -0.608122, -0.606697, -0.60529, -0.603898, -0.602516, -0.60114, -0.599766, -0.598392, -0.597014, -0.595638, -0.594262, -0.592886, -0.59151, -0.590132, -0.588747, -0.587351, -0.585953, -0.584565, -0.583196, -0.581857, -0.580561, -0.579296, -0.578045, -0.576789, -0.575509, -0.574187, -0.572823, -0.571433, -0.570038, -0.568655, -0.567304, -0.566, -0.564732, -0.563486, -0.562244, -0.560992, -0.559712, -0.558394, -0.557048, -0.555694, -0.55435, -0.553035, -0.551767, -0.550554, -0.549377, -0.548213, -0.547039, -0.545833, -0.544579, -0.543296, -0.541991, -0.540673, -0.539347, -0.538023, -0.536698, -0.535368, -0.534033, -0.532691, -0.531345, -0.529992, -0.528625, -0.527247, -0.525867, -0.524493, -0.523133, -0.521796, -0.520479, -0.519176, -0.517878, -0.51658, -0.515273, -0.513957, -0.512638, -0.511316, -0.509991, -0.508665, -0.507338, -0.506007, -0.504673, -0.503337, -0.502003, -0.500672, -0.499347, -0.498028, -0.496714, -0.495401, -0.494085, -0.492762, -0.491429, -0.490084, -0.488734, -0.487386, -0.486047, -0.484726, -0.483416, -0.482114, -0.480822, -0.479543, -0.478281, -0.477039, -0.475822, -0.474626, -0.473441, -0.47226, -0.471073, -0.469878, -0.468688, -0.467499, -0.466305, -0.465101, -0.463881, -0.462642, -0.461385, -0.460117, -0.458846, -0.457581, -0.456327, -0.455092, -0.453867, -0.452643, -0.451408, -0.450154, -0.448868, -0.447541, -0.44619, -0.444838, -0.443506, -0.442214, -0.44098, -0.439791, -0.438628, -0.437473, -0.436306, -0.43511, -0.433885, -0.432645, -0.431396, -0.430143, -0.428894, -0.427652, -0.426416, -0.425183, -0.423949, -0.422711, -0.421466, -0.420212, -0.418951, -0.417684, -0.416414, -0.415141, -0.413868, -0.412589, -0.411302, -0.410015, -0.408732, -0.407459, -0.406204, -0.404969, -0.403749, -0.402535, -0.401316, -0.400084, -0.398829, -0.397551, -0.396262, -0.394973, -0.393697, -0.392445, -0.391224, -0.390027, -0.388843, -0.387665, -0.386484, -0.385291, -0.384089, -0.382883, -0.381676, -0.380469, -0.379266, -0.378068, -0.37687, -0.375674, -0.374482, -0.373293, -0.372111, -0.370936, -0.369768, -0.368605, -0.367445, -0.366287, -0.365128, -0.36397, -0.362812, -0.361657, -0.360503, -0.359351, -0.358203, -0.357061, -0.355922, -0.354784, -0.353643, -0.352495, -0.351336, -0.350168, -0.348994, -0.34782, -0.346649, -0.345486, -0.344334, -0.343189, -0.342048, -0.340906, -0.339762, -0.338611, -0.337458, -0.336305, -0.335148, -0.333984, -0.33281, -0.331624, -0.330426, -0.329218, -0.328005, -0.326791, -0.32558, -0.324371, -0.323158, -0.321945, -0.320736, -0.319535, -0.318345, -0.317165, -0.315991, -0.314825, -0.313666, -0.312516, -0.311376, -0.310249, -0.309132, -0.30802, -0.30691, -0.305796, -0.304683, -0.30358, -0.302479, -0.301367, -0.300236, -0.299074, -0.297859, -0.296599, -0.295325, -0.294068, -0.292855, -0.291717, -0.290659, -0.289654, -0.28867, -0.287676, -0.286641, -0.28555, -0.284431, -0.28329, -0.282128, -0.280946, -0.279746, -0.278513, -0.277246, -0.27596, -0.274674, -0.273405, -0.272167, -0.270948, -0.26974, -0.268546, -0.26737, -0.266215, -0.265084, -0.263983, -0.262904, -0.261837, -0.260774, -0.259706, -0.258637, -0.257578, -0.256522, -0.255458, -0.254379, -0.253276, -0.252151, -0.251008, -0.249851, -0.248684, -0.247511, -0.246333, -0.245133, -0.243922, -0.242709, -0.241508, -0.240329, -0.239178, -0.238042, -0.236921, -0.235815, -0.234725, -0.233651, -0.232605, -0.231587, -0.230582, -0.229575, -0.228551, -0.227496, -0.226409, -0.225303, -0.22419, -0.223083, -0.221996, -0.22094, -0.219911, -0.218897, -0.217885, -0.216863, -0.215818, -0.214744, -0.213651, -0.212546, -0.211438, -0.210337, -0.209249, -0.208177, -0.207112, -0.20605, -0.204984, -0.203909, -0.202819, -0.201716, -0.200605, -0.19949, -0.198377, -0.197271, -0.196173, -0.195078, -0.193985, -0.192896, -0.191809, -0.190725, -0.189653, -0.188591, -0.187529, -0.186458, -0.185368, -0.18425, -0.183097, -0.181922, -0.180741, -0.179569, -0.17842, -0.1773, -0.17619, -0.175094, -0.174015, -0.172958, -0.171927, -0.170938, -0.169986, -0.169054, -0.168122, -0.167172, -0.166186, -0.165179, -0.164157, -0.163123, -0.162077, -0.161021, -0.159952, -0.158857, -0.157749, -0.15664, -0.155542, -0.15447, -0.153432, -0.152424, -0.151428, -0.150429, -0.149413, -0.148364, -0.147283, -0.146183, -0.145069, -0.14395, -0.142834, -0.141724, -0.140608, -0.139489, -0.138373, -0.137265, -0.136171, -0.135093, -0.134025, -0.132968, -0.131919, -0.130878, -0.129844, -0.128821, -0.127809, -0.126804, -0.125801, -0.124797, -0.123787, -0.122773, -0.121758, -0.120744, -0.119733, -0.118728, -0.117733, -0.11675, -0.115771, -0.114792, -0.113806, -0.112807, -0.111794, -0.110771, -0.109741, -0.108707, -0.107672, -0.106636, -0.105591, -0.104541, -0.103491, -0.102448, -0.10142, -0.100412, -0.0994198, -0.0984399, -0.0974673, -0.0964976, -0.0955265, -0.0945581, -0.0935982, -0.0926402, -0.0916777, -0.0907045, -0.0897139, -0.0887001, -0.0876694, -0.0866321, -0.0855982, -0.0845778, -0.0835811, -0.0826095, -0.0816517, -0.0806952, -0.0797277, -0.0787369, -0.0777107, -0.0766526, -0.075579, -0.0745061, -0.0734503, -0.0724281, -0.0714473, -0.0704955, -0.0695569, -0.0686153, -0.067655, -0.0666595, -0.0656228, -0.0645626, -0.0634995, -0.0624539, -0.0614458, -0.0604904, -0.0595764, -0.0586898, -0.0578174, -0.0569453, -0.0560601, -0.0551719, -0.0542917, -0.0534099, -0.0525163, -0.0516014, -0.0506555, -0.0496757, -0.0486708, -0.0476511, -0.0466261, -0.0456061, -0.044596, -0.0435836, -0.0425703, -0.0415587, -0.040552, -0.0395533, -0.0385637, -0.0375815, -0.0366045, -0.0356314, -0.0346604, -0.0336902, -0.0327247, -0.0317635, -0.0308037, -0.0298422, -0.0288762, -0.0279032, -0.026925, -0.025943, -0.0249582, -0.0239714, -0.0229839, -0.0219896, -0.0209822, -0.0199722, -0.0189704, -0.0179881, -0.0170357, -0.0161152, -0.0152188, -0.0143404, -0.0134736, -0.0126123, -0.0117534, -0.0109179, -0.0100977, -0.00927668, -0.00843894, -0.0075681, -0.00664104, -0.0056472, -0.00462252, -0.00360524, -0.00263304, -0.00174417,
		0.00221683, 0.00288535, 0.00382874, 0.00493397, 0.006088, 0.00717778, 0.0080962, 0.00887097, 0.00957292, 0.0102536, 0.0109644, 0.0117569, 0.0126765, 0.0137091, 0.014811, 0.0159388, 0.0170492, 0.0180987, 0.0190781, 0.0200243, 0.0209441, 0.0218439, 0.0227299, 0.023608, 0.0244664, 0.0253042, 0.0261303, 0.0269533, 0.0277823, 0.0286234, 0.0294678, 0.0303142, 0.0311635, 0.0320168, 0.0328749, 0.0337369, 0.0346001, 0.0354672, 0.0363411, 0.0372246, 0.0381206, 0.0390346, 0.039964, 0.0409017, 0.0418407, 0.042774, 0.0436961, 0.0446189, 0.0455409, 0.0464563, 0.047359, 0.0482433, 0.0491029, 0.049938, 0.0507563, 0.0515658, 0.0523744, 0.0531901, 0.0540067, 0.0548165, 0.0556269, 0.0564456, 0.0572799, 0.0581378, 0.0590252, 0.059934, 0.0608529, 0.0617707, 0.0626761, 0.0635623, 0.0644415, 0.0653142, 0.0661789, 0.0670339, 0.0678778, 0.0687058, 0.0695165, 0.070317, 0.0711147, 0.0719168, 0.0727304, 0.0735539, 0.0743828, 0.075215, 0.0760485, 0.0768811, 0.07771, 0.0785292, 0.0793449, 0.0801652, 0.080998, 0.0818513, 0.082737, 0.0836581, 0.0845968, 0.0855346, 0.0864532, 0.0873342, 0.0881769, 0.0889945, 0.0897932, 0.0905797, 0.0913603, 0.0921398, 0.0929034, 0.0936544, 0.0944023, 0.0951566, 0.0959267, 0.0967196, 0.0975297, 0.0983516, 0.09918, 0.10001, 0.100836, 0.101666, 0.102504, 0.103342, 0.104172, 0.104985, 0.105773, 0.106533, 0.107272, 0.107999, 0.108722, 0.109449, 0.110184, 0.110909, 0.11163, 0.112359, 0.113107, 0.113883, 0.114701, 0.115559, 0.116438, 0.117321, 0.118187, 0.119019, 0.11982, 0.120602, 0.121371, 0.122131, 0.122889, 0.123648, 0.124405, 0.125157, 0.125905, 0.126649, 0.127387, 0.128116, 0.128828, 0.129533, 0.130244, 0.130971, 0.131727, 0.132522, 0.133348, 0.134189, 0.13503, 0.135856, 0.136654, 0.137426, 0.138182, 0.13893, 0.13968, 0.140439, 0.141215, 0.142006, 0.142805, 0.143602, 0.144389, 0.145159, 0.145905, 0.146633, 0.147351, 0.148066, 0.148785, 0.149516, 0.150256, 0.151, 0.151747, 0.152495, 0.153242, 0.15399, 0.154742, 0.155496, 0.156248, 0.156992, 0.157725, 0.158443, 0.15915, 0.159849, 0.160542, 0.16123, 0.161916, 0.162592, 0.163258, 0.163921, 0.164589, 0.165267, 0.165962, 0.166664, 0.167374, 0.168094, 0.168827, 0.169575, 0.170347, 0.171149, 0.171967, 0.172788, 0.173595, 0.174376, 0.175127, 0.17586, 0.17658, 0.177293, 0.178003, 0.178717, 0.179439, 0.180163, 0.180879, 0.181579, 0.182254, 0.182887, 0.183461, 0.184006, 0.184553, 0.185136, 0.185786, 0.186519, 0.187312, 0.188146, 0.189001, 0.189859, 0.190701, 0.191556, 0.192426, 0.193296, 0.194149, 0.194968, 0.195739, 0.19647, 0.197172, 0.197852, 0.198518, 0.199177, 0.199827, 0.200455, 0.20107, 0.201683, 0.202303, 0.202941, 0.203594, 0.204255, 0.204924, 0.205599, 0.206279, 0.206967, 0.207672, 0.208389, 0.209106, 0.209812, 0.210497, 0.211154, 0.211791, 0.212413, 0.213022, 0.213622, 0.214216, 0.214789, 0.215338, 0.21588, 0.216432, 0.21701, 0.217632, 0.218309, 0.219022, 0.219748, 0.220466, 0.221152, 0.221789, 0.222391, 0.22297, 0.223536, 0.224097, 0.224665, 0.225227, 0.225769, 0.22631, 0.226866, 0.227457, 0.2281, 0.228809, 0.229566, 0.230349, 0.231134, 0.231897, 0.232619, 0.233316, 0.233998, 0.234672, 0.235345, 0.236023, 0.236715, 0.237415, 0.238118, 0.238815, 0.239499, 0.240162, 0.240802, 0.241424, 0.242035, 0.242638, 0.24324, 0.243846, 0.244452, 0.245055, 0.245654, 0.24625, 0.246841, 0.247425, 0.248001, 0.248572, 0.249141, 0.249711, 0.250285, 0.250867, 0.251454, 0.252043, 0.252627, 0.253202, 0.253762, 0.254314, 0.254859, 0.255395, 0.255918, 0.256428, 0.256916, 0.257372, 0.257809, 0.258245, 0.258695, 0.259177, 0.259689, 0.260217, 0.260762, 0.26133, 0.261924, 0.262549, 0.263221, 0.263934, 0.264667, 0.2654, 0.266114, 0.266792, 0.267451, 0.268097, 0.268732, 0.269357, 0.269973, 0.270576, 0.271158, 0.271729, 0.2723, 0.272879, 0.273479, 0.274107, 0.274757, 0.275414, 0.276063, 0.27669, 0.277282, 0.277837, 0.278368, 0.278887, 0.279406, 0.279937, 0.280489, 0.281057, 0.281633, 0.282207, 0.282772, 0.283319, 0.283845, 0.284355, 0.284855, 0.285351, 0.285848, 0.286353, 0.286861, 0.287368, 0.287877, 0.288389, 0.288904, 0.289424, 0.289941, 0.290461, 0.290987, 0.291524, 0.292076, 0.292648, 0.293238, 0.293841, 0.294449, 0.295058, 0.295663, 0.296276, 0.296899, 0.297519, 0.298127, 0.29871, 0.299257, 0.299765, 0.300247, 0.300716, 0.301185, 0.301669, 0.302178, 0.302707, 0.303244, 0.303774, 0.304286, 0.304765, 0.305192, 0.305574, 0.305941, 0.306323, 0.306748, 0.307245, 0.307827, 0.308466, 0.309123, 0.309764, 0.310351, 0.310859, 0.311312, 0.311727, 0.312122, 0.312512, 0.312915, 0.313329, 0.313739, 0.314148, 0.314558, 0.314972, 0.315393, 0.315812, 0.316231, 0.316656, 0.317095, 0.317554, 0.318043, 0.318572, 0.319125, 0.319683, 0.320227, 0.320739, 0.321207, 0.321641, 0.322057, 0.322467, 0.322886, 0.323327, 0.32378, 0.324239, 0.324707, 0.325188, 0.325686, 0.326205, 0.326755, 0.327327, 0.327907, 0.328484, 0.329045, 0.329585, 0.330116, 0.33064, 0.331156, 0.331664, 0.332165, 0.332653, 0.33313, 0.3336, 0.334068, 0.334539, 0.33502, 0.33552, 0.33603, 0.336536, 0.337024, 0.337481, 0.337893, 0.338261, 0.3386, 0.338927, 0.339258, 0.33961, 0.339982, 0.340358, 0.340742, 0.341136, 0.341541, 0.34196, 0.342407, 0.342874, 0.343348, 0.343815, 0.344261, 0.344675, 0.345061, 0.345429, 0.345787, 0.346144, 0.346507, 0.346879, 0.347253, 0.347628, 0.348002, 0.348377, 0.34875, 0.349118, 0.349481, 0.349845, 0.350216, 0.350597, 0.350995, 0.351411, 0.351838, 0.352273, 0.352708, 0.353139, 0.353563, 0.353984, 0.354404, 0.354824, 0.355243, 0.355661, 0.356077, 0.356489, 0.356901, 0.357316, 0.357737, 0.358168, 0.358608, 0.359055, 0.359506, 0.35996, 0.360414, 0.360869, 0.361328, 0.361789, 0.36225, 0.362706, 0.363154, 0.363596, 0.364034, 0.364466, 0.364893, 0.365313, 0.365724, 0.366133, 0.366538, 0.366935, 0.367317, 0.367681, 0.36802, 0.368324, 0.368606, 0.36888, 0.369159, 0.369458, 0.369786, 0.370135, 0.370494, 0.370854, 0.371206, 0.371541, 0.371852, 0.372145, 0.372432, 0.372726, 0.373037, 0.373377, 0.373753, 0.374151, 0.374555, 0.374948, 0.375316, 0.375645, 0.375944, 0.376225, 0.376497, 0.376772, 0.377061, 0.377367, 0.377681, 0.377998, 0.378314, 0.378622, 0.378916, 0.379197, 0.379469, 0.379735, 0.380002, 0.380274, 0.380552, 0.380831, 0.38111, 0.381395, 0.381687, 0.381992, 0.382311, 0.382642, 0.382983, 0.383329, 0.383676, 0.384021, 0.384367, 0.384716, 0.385066, 0.385417, 0.385767, 0.386116, 0.38647, 0.386824, 0.387177, 0.387522, 0.387858, 0.388187, 0.388517, 0.388841, 0.389149, 0.389433, 0.389684, 0.389883, 0.390037, 0.390171, 0.39031, 0.390476, 0.390693, 0.390945, 0.391221, 0.391516, 0.391825, 0.392141, 0.392465, 0.392808, 0.393164, 0.393524, 0.393881, 0.394226, 0.39456, 0.394891, 0.395217, 0.395538, 0.395851, 0.396157, 0.396451, 0.396736, 0.397016, 0.397296, 0.39758, 0.397874, 0.39818, 0.39849, 0.398797, 0.399095, 0.399375, 0.399634, 0.399877, 0.400107, 0.400331, 0.400554, 0.40078, 0.401001, 0.401216, 0.401431, 0.401652, 0.401885, 0.402136, 0.402411, 0.402699, 0.402992, 0.403279, 0.403551, 0.403804, 0.404051, 0.404289, 0.404515, 0.404728, 0.404924, 0.405086, 0.405215, 0.405334, 0.405465, 0.405629, 0.405848, 0.406118, 0.406424, 0.406751, 0.407085, 0.407412, 0.407728, 0.408054, 0.408384, 0.408707, 0.409011, 0.409286, 0.40952, 0.409718, 0.409896, 0.410074, 0.410268, 0.410495, 0.410756, 0.411038, 0.411329, 0.411618, 0.411891, 0.412139, 0.41237, 0.412589, 0.412802, 0.413013, 0.413229, 0.413447, 0.413663, 0.413878, 0.414097, 0.414321, 0.414556, 0.4148, 0.415051, 0.415309, 0.41557, 0.415834, 0.416101, 0.416385, 0.416677, 0.416965, 0.417238, 0.417483, 0.417691, 0.417871, 0.418029, 0.418173, 0.418311, 0.418451, 0.418583, 0.418702, 0.418816, 0.418934, 0.419064, 0.419214, 0.419382, 0.419563, 0.419752, 0.419942, 0.42013, 0.420312, 0.420491, 0.420669, 0.420849, 0.42103, 0.421215, 0.421399, 0.421577, 0.421758, 0.421949, 0.42216, 0.422397, 0.422673, 0.422978, 0.423295, 0.423607, 0.4239, 0.424162, 0.424418, 0.424664, 0.424892, 0.425091, 0.425255, 0.425365, 0.425417, 0.425437, 0.425453, 0.425491, 0.425579, 0.425726, 0.425913, 0.426116, 0.426313, 0.426481, 0.426598, 0.42666, 0.426688, 0.426709, 0.426745, 0.42682, 0.426953, 0.427125, 0.427325, 0.427539, 0.427754, 0.427957, 0.428158, 0.428365, 0.428571, 0.42877, 0.428954, 0.429116, 0.429254, 0.429373, 0.429483, 0.429592, 0.429707, 0.429833, 0.429956, 0.43008, 0.430211, 0.430356, 0.43052, 0.430711, 0.430923, 0.431151, 0.431385, 0.431618, 0.431843, 0.432075, 0.432315, 0.43255, 0.432772, 0.432969, 0.43313, 0.43326, 0.433365, 0.433455, 0.433539, 0.433624, 0.4337, 0.433748, 0.43379, 0.433848, 0.433947, 0.434111, 0.434373, 0.434713, 0.435083, 0.435437, 0.435726, 0.435907, 0.435996, 0.436022, 0.436011, 0.435989, 0.435982, 0.435999, 0.436012, 0.436022, 0.436035, 0.436054, 0.436083, 0.436125, 0.436177, 0.436234, 0.436294, 0.436352, 0.436403, 0.436434, 0.436453, 0.436478, 0.436526, 0.436614, 0.43676, 0.436966, 0.437211, 0.43747, 0.43772, 0.437936, 0.438113, 0.438274, 0.43842, 0.438554, 0.438679, 0.438796, 0.438898, 0.438986, 0.439067, 0.439145, 0.439229, 0.439323, 0.439421, 0.439522, 0.439625, 0.43973, 0.439836, 0.439943, 0.440053, 0.440164, 0.440277, 0.440389, 0.440502, 0.440621, 0.440748, 0.440873, 0.440989, 0.441088, 0.441163, 0.441213, 0.441245, 0.441266, 0.441282, 0.441302, 0.441323, 0.441334, 0.441341, 0.441354, 0.441383, 0.441436, 0.44152, 0.441628, 0.441752, 0.441883, 0.442013, 0.442135, 0.44226, 0.44239, 0.442518, 0.442638, 0.442745, 0.44283, 0.442892, 0.442939, 0.442982, 0.443033, 0.4431, 0.443186, 0.443279, 0.443381, 0.443494, 0.443621, 0.443764, 0.443936, 0.444132, 0.444338, 0.444539, 0.44472, 0.444871, 0.445005, 0.445125, 0.445231, 0.445322, 0.445397, 0.445451, 0.445479, 0.445491, 0.445496, 0.445505, 0.445526, 0.445556, 0.445586, 0.445621, 0.445663, 0.445715, 0.445779, 0.445858, 0.445947, 0.446044, 0.446145, 0.446248, 0.44635, 0.446452, 0.446557, 0.446667, 0.446784, 0.446909, 0.447046, 0.447194, 0.447348, 0.447505, 0.447661, 0.447814, 0.447987, 0.448173, 0.448351, 0.4485, 0.448599, 0.448623, 0.448552, 0.448426, 0.448289, 0.448186, 0.448161, 0.448239, 0.448392, 0.44859, 0.448805, 0.449007, 0.449168, 0.449302, 0.449424, 0.449536, 0.449637, 0.449728, 0.44981, 0.449878, 0.449934, 0.449982, 0.450025, 0.450064, 0.450101, 0.45013, 0.450154, 0.450176, 0.450199, 0.450225, 0.450252, 0.450279, 0.450307, 0.450338, 0.450373, 0.450413, 0.450461, 0.450514, 0.45057, 0.450625, 0.450677, 0.450725, 0.450775, 0.450825, 0.45087, 0.450906, 0.450929, 0.450938, 0.450934, 0.450921, 0.450901, 0.450877, 0.45085, 0.450811, 0.450761, 0.45071, 0.450664, 0.450633, 0.450621, 0.45062, 0.450628, 0.450649, 0.450683, 0.450732, 0.450802, 0.450892, 0.450997, 0.45111, 0.451225, 0.451334, 0.451451, 0.451579, 0.451705, 0.451819, 0.451909, 0.451964, 0.451985, 0.451981, 0.451963, 0.451939, 0.451919, 0.451906, 0.451887, 0.451865, 0.451845, 0.451832, 0.45183, 0.451841, 0.451861, 0.451888, 0.451919, 0.451949, 0.451977, 0.452007, 0.452039, 0.452071, 0.452102, 0.452129, 0.452153, 0.452177, 0.452199, 0.452217, 0.452231, 0.452237, 0.452233, 0.452219, 0.452199, 0.452179, 0.452163, 0.452155, 0.452151, 0.452149, 0.452152, 0.452159, 0.452173, 0.452194, 0.452227, 0.452267, 0.45231, 0.452352, 0.452388, 0.452422, 0.45246, 0.452497, 0.452525, 0.452538, 0.452531, 0.452507, 0.452471, 0.45242, 0.452351, 0.452262, 0.452146, 0.451988, 0.451802, 0.451605, 0.451418, 0.45126, 0.451143, 0.451054, 0.450984, 0.450924, 0.450866, 0.450801, 0.450725, 0.450645, 0.450566, 0.450496, 0.45044, 0.450406, 0.450404, 0.450422, 0.450449, 0.450469, 0.450469, 0.450438, 0.450381, 0.450308, 0.450229, 0.450154, 0.450093, 0.450049, 0.450013, 0.449983, 0.449957, 0.449933, 0.449908, 0.449892, 0.449885, 0.449877, 0.449858, 0.449822, 0.44976, 0.449688, 0.449602, 0.449498, 0.449371, 0.449217, 0.449034, 0.448826, 0.448593, 0.448337, 0.448059, 0.447758, 0.447436, 0.44709, 0.446721, 0.446331, 0.445918, 0.445483, 0.445027, 0.444548, 0.444047, 0.443524, 0.44298, 0.442413, 0.441818, 0.441202, 0.440567, 0.439919, 0.439262, 0.438614, 0.437974, 0.437319, 0.436626, 0.43587, 0.435049, 0.434402, 0.433835, 0.433123, 0.432039, 0.430358, 0.428368, 0.427503, 0.426601, 0.424216, 0.418905, 0.409225, 0.396402, 0.382576, 0.365547, 0.34307, 0.312906, 0.272788, 0.221013, 0.159633, 0.091601, 0.0198945,
	};



	template<uint tableSize>
	float InterpolateTable(const std::array<float, tableSize>& table, float phase)
	{
		assert(vidf::isPowerOfTwo(tableSize));
		float ph = phase * tableSize;
		int low = int(ph) & (tableSize - 1);
		int hi = (low + 1) & (tableSize - 1);
		float fr = ph - std::floor(ph);
		return table[low] + (table[hi] - table[low]) * fr;
	}



}



namespace musicdsp
{



	class BiquadFilter
	{
	public:
		typedef float smp_type;

		smp_type a0, a1, a2, a3, a4;
		smp_type x1 = 0.0;
		smp_type x2 = 0.0;
		smp_type y1 = 0.0;
		smp_type y2 = 0.0;

		enum Type
		{
			LPF, /* low pass filter */
			HPF, /* High pass filter */
			BPF, /* band pass filter */
			NOTCH, /* Notch Filter */
			PEQ, /* Peaking band EQ filter */
			LSH, /* Low shelf filter */
			HSH, /* High shelf filter */
			APF, /* all pass filter */
		};

		smp_type Proccess(smp_type sample)
		{
			smp_type result;
			/* compute result */
			result =
				a0 * sample + a1 * x1 + a2 * x2 -
				a3 * y1 - a4 * y2;
			/* shift x1 to x2, sample to x1 */
			x2 = x1;
			x1 = sample;
			/* shift y1 to y2, result to y1 */
			y2 = y1;
			y1 = result;
			return result;
		}


		void Setup(Type type, smp_type dbGain, smp_type freq, smp_type srate, smp_type bandwidth)
		{
			const smp_type M_PI = std::acos(-1.0f);
			const smp_type M_LN2 = std::log(2.0f);

			smp_type A, omega, sn, cs, alpha, beta;
			smp_type a0, a1, a2, b0, b1, b2;

			/* setup variables */
			A = std::pow(10.0f, dbGain / 40.0f);
			omega = 2 * M_PI * freq / srate;
			sn = sin(omega);
			cs = cos(omega);
			alpha = sn * sinh(M_LN2 / 2 * bandwidth * omega / sn);
			beta = sqrt(A + A);

			switch (type)
			{
			case LPF:
				b0 = (1 - cs) / 2;
				b1 = 1 - cs;
				b2 = (1 - cs) / 2;
				a0 = 1 + alpha;
				a1 = -2 * cs;
				a2 = 1 - alpha;
				break;
			case HPF:
				b0 = (1 + cs) / 2;
				b1 = -(1 + cs);
				b2 = (1 + cs) / 2;
				a0 = 1 + alpha;
				a1 = -2 * cs;
				a2 = 1 - alpha;
				break;
			case BPF:
				b0 = alpha;
				b1 = 0;
				b2 = -alpha;
				a0 = 1 + alpha;
				a1 = -2 * cs;
				a2 = 1 - alpha;
				break;
			case NOTCH:
				b0 = 1;
				b1 = -2 * cs;
				b2 = 1;
				a0 = 1 + alpha;
				a1 = -2 * cs;
				a2 = 1 - alpha;
				break;
			case PEQ:
				b0 = 1 + (alpha * A);
				b1 = -2 * cs;
				b2 = 1 - (alpha * A);
				a0 = 1 + (alpha / A);
				a1 = -2 * cs;
				a2 = 1 - (alpha / A);
				break;
			case LSH:
				b0 = A * ((A + 1) - (A - 1) * cs + beta * sn);
				b1 = 2 * A * ((A - 1) - (A + 1) * cs);
				b2 = A * ((A + 1) - (A - 1) * cs - beta * sn);
				a0 = (A + 1) + (A - 1) * cs + beta * sn;
				a1 = -2 * ((A - 1) + (A + 1) * cs);
				a2 = (A + 1) + (A - 1) * cs - beta * sn;
				break;
			case HSH:
				b0 = A * ((A + 1) + (A - 1) * cs + beta * sn);
				b1 = -2 * A * ((A - 1) + (A + 1) * cs);
				b2 = A * ((A + 1) + (A - 1) * cs - beta * sn);
				a0 = (A + 1) - (A - 1) * cs + beta * sn;
				a1 = 2 * ((A - 1) - (A + 1) * cs);
				a2 = (A + 1) - (A - 1) * cs - beta * sn;
				break;
			case APF:
				b0 = 1.0 - alpha;
				b1 = -2.0 * cs;
				b2 = 1.0 + alpha;
				a0 = 1.0 + alpha;
				a1 = -2.0 * cs;
				a2 = 1.0 - alpha;
				break;
			}
			/* precompute the coefficients */
			this->a0 = b0 / a0;
			this->a1 = b1 / a0;
			this->a2 = b2 / a0;
			this->a3 = a1 / a0;
			this->a4 = a2 / a0;
		}
	};



	const uint sampleRate = 44100;


	class Phaser {
	public:
		Phaser()  //initialise to some usefull defaults...
			: _fb(.7f)
			, _lfoPhase(0.f)
			, _depth(1.f)
			, _zm1(0.f)
		{
			Range(440.f, 1600.f);
			Rate(.5f);
		}

		void Range(float fMin, float fMax) { // Hz
			_dmin = fMin / (sampleRate / 2.f);
			_dmax = fMax / (sampleRate / 2.f);
		}

		void Rate(float rate) { // cps
			_lfoInc = 2.f * PI * (rate / sampleRate);
		}

		void Feedback(float fb) { // 0 -> <1.
			_fb = fb;
		}

		void Depth(float depth) {  // 0 -> 1.
			_depth = depth;
		}

		void Phase(float phase) {  // 0 -> 1.
			_lfoPhase = phase * PI * 2.f;
		}

		float Update(float inSamp) {
			//calculate and update phaser sweep lfo...
			float d = _dmin + (_dmax - _dmin) * ((sin(_lfoPhase) +
				1.f) / 2.f);
			_lfoPhase += _lfoInc;
			if (_lfoPhase >= PI * 2.f)
				_lfoPhase -= PI * 2.f;

			//update filter coeffs
			for (int i = 0; i<6; i++)
				_alps[i].Delay(d);

			//calculate output
			float y = _alps[0].Update(
				_alps[1].Update(
					_alps[2].Update(
						_alps[3].Update(
							_alps[4].Update(
								_alps[5].Update(inSamp + _zm1 * _fb))))));
			_zm1 = y;

			return inSamp + y * _depth;
		}
	private:
		class AllpassDelay {
		public:
			AllpassDelay()
				: _a1(0.f)
				, _zm1(0.f)
			{}

			void Delay(float delay) { //sample delay time
				_a1 = (1.f - delay) / (1.f + delay);
			}

			float Update(float inSamp) {
				float y = inSamp * -_a1 + _zm1;
				_zm1 = y * _a1 + inSamp;

				return y;
			}
		private:
			float _a1, _zm1;
		};

		AllpassDelay _alps[6];

		float _dmin, _dmax; //range
		float _fb; //feedback
		float _lfoPhase;
		float _lfoInc;
		float _depth;

		float _zm1;
	};



	class StateFilter
	{
	public:
		void Setup(float cutoff, float resonance, float dT)
		{
			const float F = cutoff;
			const float Q = resonance;

			Q1 = 1 / Q;
			F1 = 2 * PI * F * dT;
			F1 = 2 * std::sin(PI * F * dT);
		}

		void Proccess(float sample)
		{
			const float I = sample;

			L = D2 + F1 * D1;
			H = I - L - Q1 * D1;
			B = F1 * H + D1;
			N = H + L;
			D1 = B;
			D2 = L;
		}

		float F1;
		float Q1;

		float D1 = 0.0f;
		float D2 = 0.0f;

		float L = 0.0f;
		float H = 0.0f;
		float B = 0.0f;
		float N = 0.0f;
	};



}



#pragma comment(lib, "Winmm.lib")
#pragma comment(lib, "dsound.lib")
#include <Mmsystem.h>
#include <dsound.h>


namespace
{


	inline float Frac(float x)
	{
		return x - std::floor(x);
	}



	inline float Sinc(float x)
	{
		return x == 0 ? 1.0f : std::sin(x) / x;
	}


	inline float NormSinc(float x)
	{
		return x == 0 ? 1.0f : std::sin(PI * x) / (PI * x);
	}



	class BandlimitWavetable
	{
	public:
		enum DefaultTable
		{
			Saw
		};

	public:
		BandlimitWavetable(DefaultTable defaultTable)
		{
			std::array<float, 2048> _table;
			for (uint i = 0; i < _table.size(); ++i)
				_table[i] = i / float(_table.size()) * 2.0 - 1.0;
			GenerateTable(_table.data(), uint(_table.size()));
		}

		BandlimitWavetable(const float* _table, uint _tablesize)
		{
			GenerateTable(_table, _tablesize);
		}

		float Lookup(float phase, float ddx) const
		{
			/*
			const float invLn2 = 1.0 / std::log(2.0);
		//	float level = std::log(tableSize * ddx) * invLn2;
			float level = fastlog2(tableSize * ddx);
		//	float level = 0.0;
			float l0 = LookupLevel(phase, int(level));
			float l1 = LookupLevel(phase, int(level + 1));
			return Lerp(l0, l1, Frac(level));
			*/

			const float level = fastlog2(tableSize * ddx);
			const float l0 = LookupLevel(phase, int(level));
			return l0;
		}

	private:
		void GenerateTable(const float* _table, uint _tablesize)
		{
			assert(isPowerOfTwo(_tablesize));
			tableSize = _tablesize;
			mipLevels = uint(std::log(_tablesize) / std::log(2.0));
			table.resize(_tablesize * mipLevels);
			for (uint i = 0; i < _tablesize; ++i)
				table[i] = _table[i];
			for (uint i = 1; i < mipLevels; ++i)
				GenerateMip(_table, _tablesize, i);
		}

		float LookupLevel(float phase, uint level) const
		{
			const uint tableOffset = tableSize * level;
			float ph = phase * tableSize;
			int low = int(ph) & (tableSize - 1);
			int hi = (low + 1) & (tableSize - 1);
			return Lerp(table[tableOffset + low], table[tableOffset + hi], Frac(ph));
		}

		void GenerateMip(const float* _table, uint _tablesize, uint level)
		{
			const float dx = 1.0 / std::pow(2.0f, level);
			for (int i = 0; i < _tablesize; ++i)
			{
				float sum = 0.0;
				float w = 0.0;
				for (int j = -int(_tablesize) / 2; j < int(_tablesize) / 2; ++j)
				{
					const float x = j * dx;
					const float y = NormSinc(x);
					sum += _table[(i + j) & (_tablesize - 1)] * y;
					w += y;
				}
				table[_tablesize * level + i] = sum * dx;
			}
		}

	private:
		std::vector<float> table;
		uint tableSize;
		uint mipLevels;
	};

	const BandlimitWavetable digitalSawTable{ BandlimitWavetable::Saw };
	const BandlimitWavetable analogSawTable{ vcv::sawTable.data(), uint(vcv::sawTable.size()) };




	template<typename T, uint size>
	class RingBuffer
	{
	public:
		RingBuffer()
		{
			assert(vidf::isPowerOfTwo(size));
		}

		uint GetHeadPosition() const
		{
			return head;
		}

		void SetHeadPosition(uint pos)
		{
			head = pos & (size - 1);
		}

		void Insert(T* begin, T* end)
		{
			while (begin != end)
			{
				buffer[head] = *begin++;
				head = (head + 1) & (size - 1);
			}
		}

		void CopyInto(uint offset, T* begin, T* end)
		{
			uint i = (head + offset) & (size - 1);
			while (begin != end)
			{
				*begin++ = buffer[i];
				i = (i + 1) & (size - 1);
			}
		}

		const T operator[](int idx) const
		{
			idx = (head + idx) & (size - 1);
			return buffer[idx];
		}
		T& operator[](int idx)
		{
			idx = (head + idx) & (size - 1);
			return buffer[idx];
		}

	private:
		std::array<T, size> buffer;
		uint head = 0;
	};



	template<typename T, uint size>
	float CubicInterpolateRingBuffer(const RingBuffer<T, size>& ring, float position)
	{
		int idx = int(position);
		float fr = position - std::floor(position);
		T s0 = ring[idx - 1];
		T s1 = ring[idx];
		T s2 = ring[idx + 1];
		T s3 = ring[idx + 2];
		return Cubic(s0, s1, s2, s3, fr);
	}



	class Oscilloscope
	{
	private:
		static const uint numSamples = 2048 * 4;
	public:
		Oscilloscope()
		{
		}

		void AddSamples(float* _leftSamples, float* _rightSamples, uint numSamples, Time cpuTime)
		{
			std::lock_guard<std::mutex> guard(mtx);
			leftWrite.Insert(_leftSamples, _leftSamples + numSamples);
			rightWrite.Insert(_rightSamples, _rightSamples + numSamples);
			addedSamplesWrite += numSamples;
			cpuTimeWrite += cpuTime;
		}

		void Draw()
		{
			ReadBuffer();

			glLineWidth(3.0f);
			glColor4ub(192, 0, 0, 255);
			glBegin(GL_LINE_LOOP);
			glVertex2f(0.0f, 0.0f);
			glVertex2f(1.0f, 0.0f);
			glVertex2f(1.0f, 1.0f);
			glVertex2f(0.0f, 1.0f);
			glEnd();

			glLineWidth(1.0f);
			glColor4ub(192, 255, 32, 64);

			glColor4ub(192, 255, 32, 64);
			DrawOscilloscope(leftRead, leftYOffset);

			glColor4ub(32, 192, 255, 64);
			DrawOscilloscope(rightRead, rightYOffset);

			const float cpuUsage = cpuTimeRead.AsFloat() / (addedSamplesRead / 44100.0f);
			glLineWidth(2.0f);
			glColor4ub(32, 128, 192, 255);
			glBegin(GL_LINES);
			glVertex2f(0.95f, 0.0f);    glVertex2f(1.05f, 0.0f);
			glVertex2f(0.975f, 0.125f); glVertex2f(1.025f, 0.125f);
			glVertex2f(0.975f, 0.25f);  glVertex2f(1.025f, 0.25f);
			glVertex2f(0.975f, 0.375f); glVertex2f(1.025f, 0.375f);
			glVertex2f(0.95f, 0.5f);    glVertex2f(1.05f, 0.5f);
			glEnd();
			glLineWidth(5.0f);
			glColor4ub(64, 192, 255, 255);
			glBegin(GL_LINES);
			glVertex2f(1.0f, 0.0f);
			glVertex2f(1.0f, cpuUsage * 0.5f);
			glEnd();
		}

	private:
		void DrawOscilloscope(const std::array<float, numSamples>& samples, float yOffset);

		void ReadBuffer()
		{
			std::lock_guard<std::mutex> guard(mtx);
			leftWrite.CopyInto(0, leftRead.data(), leftRead.data() + numSamples);
			rightWrite.CopyInto(0, rightRead.data(), rightRead.data() + numSamples);
			cpuTimeRead = cpuTimeWrite;
			addedSamplesRead = addedSamplesWrite;
			cpuTimeWrite = Time();
			addedSamplesWrite = 0;
		}

	private:
		RingBuffer<float, numSamples> leftWrite;
		RingBuffer<float, numSamples> rightWrite;
		std::array<float, numSamples> leftRead;
		std::array<float, numSamples> rightRead;
		uint  addedSamplesWrite = 0;
		uint  addedSamplesRead = 0;
		Time cpuTimeWrite;
		Time cpuTimeRead;
		std::mutex mtx;
		float rate = 4.0f;
		float trigger = 0.0f;
		float scale = 0.25f;
		float leftYOffset = 0.75f;
		float rightYOffset = 0.25f;
	};



	const float semiTone = 1.0 / 128.0;


	float NoteToPitch(float note)
	{
		const float f0 = 440.0;
		const float a = std::pow(2.0, 1.0 / 12.0);
		return f0 * std::pow(a, note * 128.0f - 57.0f);
	}



	float AmpToDb(float amp)
	{
		const float invLog10 = 1.0 / std::log(10.0);
		return 10.0 * (std::log(amp) * invLog10);
	}



	float DbToAmp(float db)
	{
		return std::pow(10.0f, db / 10.0f);
	}



	unsigned char SysXBuffer[256];
	unsigned char SysXFlag = 0;



	const float π = std::acos(-1.0);
	const uint sampleRate = 44100;
	const float invSmpRate = 1.0 / sampleRate;
	// const uint blockSize = 32;
	const uint blockSize = 128;
	const uint oversample = 8;
	const float invOversample = 1.0 / oversample;



	struct Oscillator
	{
		float pitch = 0.0;
		float waveMix = 0.0;
		float pw = 0.0;
		float analog = 0.0;
	};



	struct Envelope
	{
		void Set(float _attackTime, float _decayTime, float _sustain, float _releaseTime)
		{
			attackTime = _attackTime;
			attackSlope = 1.0 / _attackTime;
			decay = std::log(2.0) / _decayTime * invSmpRate;
			sustain = _sustain;
			release = std::log(2.0) / _releaseTime * invSmpRate;
		}

		float attackSlope = 0.0;
		float attackTime = 0.0;
		float decay = 0.0;
		float sustain = 1.0;
		float release = 1.0;
	};



	struct Filter
	{
		enum Type
		{
			LowPass,
			BandPass,
			HighPass,
			Notch,
		};
		Type type = LowPass;
		float cuttoff = 1.0;
		float resonance = 0.0;
		float envelope = 0.0;
		float keyFollow = 0.0;
	};



	struct LadderFilter
	{
		float cuttoff = 1.0;
		float resonance = 0.0;
		float drive = 0.0;
		float envelope = 0.0;
		float keyFollow = 0.0;
	};



	struct Saturator
	{
		enum Type
		{
			Soft,
		};
		Type type = Soft;
		float amount = 0.0;
		float mix = 0.0;
	};



	enum class ModSource
	{
		// perfomance
		PitchBend,
		ModWheel,

		// voice
		Pitch,
		Velocity,
		AmpEnv,
		FilterEnv,
		Mod0Env,
		Mod1Env,

		Count,
	};


	enum class ModDest : uint
	{
		VoiceGain,
		VoicePan,

		Osc0Pitch,
		Osc1Pitch,

		Filter0Cuttoff,
		Filter0Resonance,
		Filter0Env,
		Filter0KeyFollow,
		Filter0Drive,

		Filter1Cuttoff,
		Filter1Resonance,
		Filter1Env,
		Filter1KeyFollow,

		Count,
	};


	struct ModEntry
	{
		ModEntry() = default;
		ModSource source = ModSource::Velocity;
		ModDest   dest = ModDest::VoiceGain;
		float    amount = 1.0;
	};


	struct Phaser
	{
		bool enabled = false;
	};



	struct Delay
	{
		bool enabled = false;
	};


	struct Patch
	{
		Oscillator oscillator[2];
		float oscillatorMix = 0.0;

		Envelope ampEnv;
		Envelope filterEnv;
		Envelope modEnv[2];

		enum FilterMode
		{
			Filter_2Pole,
			Filter_4Pole,
			Filter_Ladder,
		};

		FilterMode   filterMode = Filter_2Pole;
		Filter       filter[2];
		LadderFilter ladderFilter;
		Saturator    saturator;

		std::vector<ModEntry> modulators;

		Phaser phaser;
		Delay  delay;

		float master = DbToAmp(-3.0);
	};



	enum class State
	{
		Active,
		Release,
		Free,
	};



	struct _Voice;


	struct OscillatorState
	{
		inline void Trigger()
		{
			phase = 0.0;
			sawMinBLEP.minblep = vcv::minblep_16_32;
			sawMinBLEP.oversample = 32;
		}

		void Modulate(const Oscillator& _oscillator, const _Voice& voice);

		inline float SubStep(const Oscillator& oscillator)
		{
			const float waveMix = oscillator.waveMix;
			const float analogAmt = oscillator.analog;
			const float pw = oscillator.pw;

			const float ph0 = phase - pw * 0.5;
			const float ph1 = phase + pw * 0.5;
			const float saw = (Saw(ph0, analogAmt) + Saw(ph1, analogAmt)) * 0.5;
			const float pulse = (Saw(ph0, analogAmt) - Saw(ph1 + 0.5, analogAmt));

			const float result = Lerp(saw, pulse, waveMix);

			phase += invSmpRate * rate;
			if (phase >= 1.0f)
				phase -= 1.0f;

			return result;
		}

		inline float Saw(float ph, float analogAmt)
		{
			const float ddx = invSmpRate * rate;
			const float analog = analogSawTable.Lookup(ph, ddx);
			const float digital = digitalSawTable.Lookup(ph, ddx);
			return Lerp(digital, analog, analogAmt);
		}

		vcv::MinBLEP<16> sawMinBLEP;
		float phase;
		float rate;
	};


	struct EnvState
	{
		inline void Trigger()
		{
			amount = 1.0;
		}

		inline float Step(const Envelope& env, State state, float timer)
		{
			if (state == State::Active)
			{
				if (timer < env.attackTime)
					amount = env.attackSlope * timer;
				else
					amount = Lerp(amount, env.sustain, env.decay);
			}
			else if (state == State::Release)
			{
				amount = Lerp(amount, 0.0f, env.release);
			}
			return std::pow(amount, 0.5f);
		}

		float amount = 1.0;
	};



	struct FilterState
	{
		inline void Modulate(const Filter& _filter, const _Voice& voice, float resMult);

		inline float Step(float input)
		{
			const float mixWith = (type == musicdsp::BiquadFilter::LPF || type == musicdsp::BiquadFilter::NOTCH) ? input : 0.0;
			return Lerp(mixWith, filter.Proccess(input), mix);
		}

		musicdsp::BiquadFilter::Type type;
		musicdsp::BiquadFilter filter;
		float mix;
	};



	struct LadderFilterState
	{
		inline void Modulate(const LadderFilter& _filter, const _Voice& voice);

		inline float Step(float input)
		{
			ladder.process(input * drive, invSmpRate);
			return ladder.state[3];
		}

		vcv::LadderFilter ladder;
		float drive;
	};



	struct SaturatorState
	{
		inline void Modulate(const Saturator& _sat, const _Voice& voice)
		{
			type = _sat.type;
			inGain = std::pow(100.0f, _sat.amount);
			outGain = 1.0 / WaveShape(inGain);
			mix = _sat.mix;
		}

		inline float Step(float input)
		{
			float output = WaveShape(input * inGain);
			return Lerp(input, output * outGain, mix);
		}

		inline float WaveShape(float x)
		{
			switch (type)
			{
			case Saturator::Soft:
				return Sigmoid(x) * 2.0 - 1.0;
				break;
			}
		}

		Saturator::Type type;
		float inGain;
		float outGain;
		float mix;
	};



	struct _Voice
	{
		State state = State::Free;
		uint note = 0;
		uint unisonId = 0;
		float timer = 0.0;

		OscillatorState oscillator[2];
		vcv::Decimator<8, 8> decimator[2];

		EnvState ampEnv;
		EnvState filterEnv;
		EnvState modEnv[2];

		FilterState       filter[3];
		LadderFilterState ladderFilter;
		SaturatorState    saturator;

		std::array<float, size_t(ModSource::Count)> modSources;
		std::array<float, size_t(ModDest::Count)>   modDest;

		inline void Trigger(uint _note, uint _unisonId, float _velocity)
		{
			state = State::Active;
			timer = 0.0;
			note = _note;
			unisonId = _unisonId;
			modDest.fill(0.0);

			SetSource(ModSource::Velocity, _velocity);
			SetSource(ModSource::Pitch, _note / 128.0);

			ampEnv.Trigger();
			filterEnv.Trigger();
			modEnv[0].Trigger();
			modEnv[1].Trigger();
			oscillator[0].Trigger();
			oscillator[1].Trigger();
		}

		inline void Modulate(const Patch& patch)
		{
			SetSource(ModSource::AmpEnv, ampEnv.Step(patch.ampEnv, state, timer));
			SetSource(ModSource::FilterEnv, filterEnv.Step(patch.filterEnv, state, timer));
			SetSource(ModSource::Mod0Env, modEnv[0].Step(patch.modEnv[0], state, timer));
			SetSource(ModSource::Mod1Env, modEnv[1].Step(patch.modEnv[1], state, timer));

			oscillator[0].Modulate(patch.oscillator[0], *this);
			oscillator[1].Modulate(patch.oscillator[1], *this);

			switch (patch.filterMode)
			{
			case Patch::Filter_2Pole:
				filter[0].Modulate(patch.filter[0], *this, 1.0);
				filter[1].Modulate(patch.filter[1], *this, 1.0);
				break;
			case Patch::Filter_4Pole:
				filter[0].Modulate(patch.filter[0], *this, 0.5);
				filter[1].Modulate(patch.filter[0], *this, 0.5);
				filter[2].Modulate(patch.filter[1], *this, 1.0);
				break;
			case Patch::Filter_Ladder:
				ladderFilter.Modulate(patch.ladderFilter, *this);
				filter[0].Modulate(patch.filter[1], *this, 1.0);
				break;
			}

			saturator.Modulate(patch.saturator, *this);
		}

		inline float SubStep(const Patch& patch)
		{
#			ifdef SYNTH_SUPERSAMPLE
			std::array<float, oversample> buffer;
			buffer.fill(0.0);

			for (uint i = 0; i < oversample; ++i)
			{
				buffer[i] += oscillator[0].SubStep(patch.oscillator[0]) * (1.0 - patch.oscillatorMix);
				buffer[i] += oscillator[1].SubStep(patch.oscillator[1]) * patch.oscillatorMix;
			}
			float output = decimator[0].process(buffer.data());
#			else
			float output = 0.0;
			output += oscillator[0].SubStep(patch.oscillator[0]) * (1.0 - patch.oscillatorMix);
			output += oscillator[1].SubStep(patch.oscillator[1]) * patch.oscillatorMix;
#			endif

			switch (patch.filterMode)
			{
			case Patch::Filter_2Pole:
				output = filter[0].Step(output);
				output = saturator.Step(output);
				output = filter[1].Step(output);
				break;
			case Patch::Filter_4Pole:
				output = filter[0].Step(output);
				output = filter[1].Step(output);
				output = saturator.Step(output);
				output = filter[2].Step(output);
				break;
			case Patch::Filter_Ladder:
				output = ladderFilter.Step(output);
				output = filter[0].Step(output);
				break;
			}

			output *= GetSource(ModSource::AmpEnv);

			return output;
		}

		inline void Step(float* leftOut, float* rightOut, const Patch& patch)
		{
			Modulate(patch);

			const float output = SubStep(patch);

			*leftOut += output;
			*rightOut += output;

			const float ampThreshold = DbToAmp(-60.0);
			timer += invSmpRate;
			if (state == State::Release && GetSource(ModSource::AmpEnv) < ampThreshold)
			{
				state = State::Free;
				timer = 0.0;
			}
		}

		void SetSource(ModSource source, float value)
		{
			modSources[size_t(source)] = value;
		}

		float GetSource(ModSource source) const
		{
			return modSources[size_t(source)];
		}
	};



	inline void OscillatorState::Modulate(const Oscillator& _oscillator, const _Voice& voice)
	{
		float pitch = voice.GetSource(ModSource::Pitch);
		pitch += _oscillator.pitch;
		rate = NoteToPitch(Saturate(pitch));
	}



	inline void FilterState::Modulate(const Filter& _filter, const _Voice& voice, float resMult)
	{
		switch (_filter.type)
		{
		case Filter::LowPass:
			type = musicdsp::BiquadFilter::LPF;
			break;
		case Filter::BandPass:
			type = musicdsp::BiquadFilter::BPF;
			break;
		case Filter::HighPass:
			type = musicdsp::BiquadFilter::HPF;
			break;
		case Filter::Notch:
			type = musicdsp::BiquadFilter::NOTCH;
			break;
		}

		float cutoffExp = _filter.cuttoff;
		cutoffExp += voice.GetSource(ModSource::FilterEnv) * _filter.envelope;
		cutoffExp += voice.GetSource(ModSource::Pitch) * _filter.keyFollow;
		cutoffExp = Saturate(cutoffExp);
		const float minCutoff = 20.0;
		const float maxCutoff = 20000.0;
		const float maxStableCutoff = sampleRate * 0.25;
		const float cutoff = minCutoff * powf(maxCutoff / minCutoff, cutoffExp);
		const float stableCutoff = Min(cutoff, maxStableCutoff);
		mix = 1.0 - Saturate((cutoff - maxStableCutoff) / (maxCutoff - maxStableCutoff));

		float resonanceExp = _filter.resonance;
		resonanceExp = Clamp(resonanceExp * resMult, 0.0f, resMult);
		const float minBandwidth = 0.1;
		const float maxBandwidth = 2.0;
		const float bandwidth = minBandwidth * powf(maxBandwidth / minBandwidth, 1.0 - resonanceExp);

		filter.Setup(type, 0.0, stableCutoff, sampleRate, bandwidth);
	}



	inline void LadderFilterState::Modulate(const LadderFilter& _filter, const _Voice& voice)
	{
		float cutoffExp = _filter.cuttoff;
		cutoffExp += voice.GetSource(ModSource::FilterEnv) * _filter.envelope;
		cutoffExp += voice.GetSource(ModSource::Pitch) * _filter.keyFollow;
		cutoffExp = Saturate(cutoffExp);
		const float minCutoff = 15.0f;
		const float maxCutoff = 8400.0f;
		ladder.cutoff = minCutoff * powf(maxCutoff / minCutoff, cutoffExp);

		float res = _filter.resonance;
		res = 5.5f * Clamp(res, 0.0f, 1.0f);
		ladder.resonance = res;
		drive = std::pow(100.0f, _filter.drive);
	}



	static class Synth
	{
	private:
		void BasicPatch()
		{
			patch.ampEnv.Set(0.0, 0.1, 0.3, 0.05);
			patch.filterEnv.Set(0.0, 0.05, 0.0, 0.05);

			patch.filterMode = Patch::Filter_4Pole;
			patch.filter[0].type = Filter::LowPass;
			patch.filter[0].cuttoff = 0.2;
			patch.filter[0].resonance = 0.85;
			patch.filter[0].envelope = 0.65;
			patch.filter[0].keyFollow = 1.0;
		//	patch.filter[1].type = Filter::LowPass;
		//	patch.filter[1].cuttoff = 0.5;
		//	patch.filter[1].resonance = 0.0;
		//	patch.filter[1].envelope = 0.55;
			patch.filter[1].type = Filter::HighPass;
			patch.filter[1].cuttoff = 0.2;
			patch.filter[1].resonance = 0.0;
			patch.filter[1].envelope = 0.15;

			patch.saturator.type = Saturator::Soft;
			patch.saturator.amount = 0.5;
			patch.saturator.mix = 1.0;

		//	patch.phaser.enabled = true;
		//	patch.delay.enabled = true;

			phaserLeft.Range(1000.0, 4000.0);
			phaserLeft.Rate(0.25 * 0.5);
			phaserLeft.Feedback(0.9);
			phaserLeft.Depth(0.45);
			phaserRight = phaserLeft;
			phaserRight.Phase(0.25);

			patch.master = DbToAmp(-6.0);
		}

		void MoogPadPatch()
		{
			patch.ampEnv.Set(0.2, 0.35, 0.3, 0.25);
			patch.filterEnv.Set(2.0, 0.35, 0.5, 0.25);

			patch.oscillator[0].pitch = -semiTone * 0.05;
			patch.oscillator[0].analog = 1.0;
			patch.oscillator[1].pitch = semiTone * 0.05;
			patch.oscillator[1].analog = 1.0;
			patch.oscillatorMix = 0.5;

			patch.filterMode = Patch::Filter_Ladder;
			patch.ladderFilter.cuttoff = 0.4;
			patch.ladderFilter.resonance = 0.15;
			patch.ladderFilter.envelope = 0.4;
			patch.ladderFilter.drive = 0.3;
			patch.ladderFilter.keyFollow = 1.0;
			patch.filter[1].type = Filter::HighPass;
			patch.filter[1].cuttoff = 0.3;
			patch.filter[1].resonance = 0.0;
			patch.filter[1].envelope = -0.2;

			patch.delay.enabled = true;

			patch.master = DbToAmp(-6.0);
		}

		void AnalogPluckPatch()
		{
			patch.ampEnv.Set(0.0, 0.25, 0.3, 0.1);
			patch.filterEnv.Set(0.0, 0.35, 0.0, 0.25);

			patch.oscillator[0].analog = 1.0;
			patch.oscillator[0].pw = 0.35;
			patch.oscillator[0].waveMix = 0.85;

			patch.oscillator[1].analog = 0.0;
			patch.oscillator[1].pw = 0.0;
			patch.oscillator[1].waveMix = 0.0;
			patch.oscillator[1].pitch = -semiTone * 12.0;

			patch.oscillatorMix = 0.3;

			patch.filterMode = Patch::Filter_4Pole;
			patch.filter[0].type = Filter::LowPass;
			patch.filter[0].cuttoff = 0.4;
			patch.filter[0].resonance = 0.45;
			patch.filter[0].envelope = 0.35;
			patch.filter[1].type = Filter::LowPass;
			patch.filter[1].cuttoff = 0.75;
			patch.filter[1].resonance = 0.0;
			patch.filter[1].envelope = 0.15;

			patch.saturator.type = Saturator::Soft;
			patch.saturator.amount = 0.75;
			patch.saturator.mix = 0.75;

			patch.phaser.enabled = true;
			patch.delay.enabled = true;

			phaserLeft.Range(1000.0, 4000.0);
			phaserLeft.Rate(0.25 * 0.5);
			phaserLeft.Feedback(0.9);
			phaserLeft.Depth(0.45);
			phaserRight = phaserLeft;
			phaserRight.Phase(0.25);

			patch.master = DbToAmp(-6.0);
		}

	public:
		Synth()
		{
			voices.resize(32);

			// BasicPatch();
			// MoogPadPatch();
			AnalogPluckPatch();
		}

		void NoteOn(uint note, float velocity)
		{
			uint bestVoiceId = 0;
			float bestTime = 0.0;
			for (uint i = 0; i < voices.size(); ++i)
			{
				if (voices[i].state == State::Free && voices[i].timer >= bestTime)
				{
					bestVoiceId = i;
					bestTime = voices[i].timer;
				}
			}
			if (bestVoiceId == voices.size())
				return;

			voices[bestVoiceId].Trigger(note, 0, velocity);
		}

		void NoteOff(uint note)
		{
			for (uint i = 0; i < voices.size(); ++i)
			{
				if (voices[i].note == note)
					voices[i].state = State::Release;
			}
		}

		void SetCC(uint control, float value)
		{
			switch (control)
			{
			case 0:
				patch.oscillator[0].waveMix = value;
				break;
			case 1:
				patch.oscillator[0].pw = value - 0.5;
				break;
			case 2:
				patch.oscillator[0].analog = value;
				break;
			case 3:
				patch.filter[0].cuttoff = value;
				patch.ladderFilter.cuttoff = value;
				break;
			case 4:
				patch.filter[0].resonance = value;
				patch.ladderFilter.resonance = value;
				break;
			case 5:
				patch.ladderFilter.drive = value;
				break;
			case 6:
				patch.saturator.amount = value;
				break;
			case 7:
				patch.saturator.mix = value;
				break;
			case 8:
				delayModNew = value;
				break;
			case 11:
				if (value < 0.33f)
					patch.filterMode = Patch::Filter_2Pole;
				else if (value < 0.66f)
					patch.filterMode = Patch::Filter_4Pole;
				else
					patch.filterMode = Patch::Filter_Ladder;
				break;
			}
		}

		void Step(float* leftOut, float* rightOut, uint numSamples)
		{
			PROFILE

			StepVoices(leftOut, rightOut, numSamples);

			StepEffects(leftOut, rightOut, numSamples);

			for (uint i = 0; i < numSamples; ++i)
			{
				*leftOut++ *= patch.master;
				*rightOut++ *= patch.master;
			}

			timer += invSmpRate * numSamples;
		}

		Patch  patch;

	private:
		void StepVoices(float* leftOut, float* rightOut, uint numSamples)
		{
			PROFILE

			for (uint i = 0; i < voices.size(); ++i)
			{
				if (voices[i].state == State::Free)
					continue;
				for (uint j = 0; j < numSamples; ++j)
					voices[i].Step(leftOut + j, rightOut + j, patch);
			}
		}

		void StepEffects(float* leftOut, float* rightOut, uint numSamples)
		{
			PROFILE

			for (uint i = 0; i < numSamples; ++i)
			{
				if (patch.phaser.enabled)
				{
					leftOut[i] = phaserLeft.Update(leftOut[i]);
					rightOut[i] = phaserRight.Update(rightOut[i]);
				}
			}

			if (patch.delay.enabled)
			{
				leftRing.Insert(leftOut, leftOut + numSamples);
				rightRing.Insert(rightOut, rightOut + numSamples);
				for (uint i = 0; i < numSamples; ++i)
				{
					delayMod = Lerp(delayMod, delayModNew, 0.001);
					const float mix = 0.5;
					const float delay = std::pow(4.0f, delayMod * 2.0f - 1.0f) * 0.25;
					const float feedback = 0.65;

					const int writeHead = -numSamples + i;
					const float readHead = writeHead - delay * sampleRate;

					const float leftDelay = CubicInterpolateRingBuffer(leftRing, readHead);
					const float rightDelay = CubicInterpolateRingBuffer(rightRing, readHead);

					leftRing[writeHead] += leftDelay * feedback;
					rightRing[writeHead] += rightDelay * feedback;

					leftOut[i] = leftDelay + (leftOut[i] - leftDelay) * mix;
					rightOut[i] = rightDelay + (rightOut[i] - rightDelay) * mix;
				}
			}
		}

	private:
		std::vector<_Voice> voices;
		float timer = 0.0;

		RingBuffer<float, 65536> leftRing;
		RingBuffer<float, 65536> rightRing;
		float delayMod = 0.5;
		float delayModNew = 0.5;
		musicdsp::BiquadFilter leftApf;
		musicdsp::BiquadFilter rightApf;
		musicdsp::Phaser phaserLeft;
		musicdsp::Phaser phaserRight;
	} g_synth;

	Oscilloscope g_oscilloscope;



	static HMIDIIN keyboardMidi;
	static HMIDIIN nanoKorgMidi;



	void CALLBACK MidiCallback(HMIDIIN handle, UINT uMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2)
	{
		BROFILER_THREAD("MIDIThread");

		LPMIDIHDR		lpMIDIHeader;
		unsigned char *	ptr;
		char			buffer[80];
		unsigned char 	bytes;

		switch (uMsg)
		{
		case MIM_DATA:
		{
			sprintf(buffer, "0x%08X 0x%02X 0x%02X 0x%02X\r\n", dwParam2, dwParam1 & 0x000000FF, (dwParam1 >> 8) & 0x000000FF, (dwParam1 >> 16) & 0x000000FF);
			std::cout << buffer;

			if (handle == keyboardMidi)
			{
				if ((dwParam1 & 0xf0) == 0x90)
				{
					uint channel = dwParam1 & 0x0f;
					if (channel == 0)
					{
						const uint note = (dwParam1 >> 8) & 0xff;
						const uint velocity = (dwParam1 >> 16) & 0xff;
						if (velocity != 0)
							g_synth.NoteOn(note, float(velocity) / 127.0);
						else
							g_synth.NoteOff(note);
					}
				}
			}
			else if (handle == nanoKorgMidi)
			{
				if ((dwParam1 & 0xf0) == 0xb0)
				{
					const uint control = (dwParam1 >> 8) & 0xff;
					const uint value = (dwParam1 >> 16) & 0xff;
					if (control >= 0 && control < 8)
						g_synth.SetCC(control, value / float(0x7f));
					else if (control >= 16 && control < 16 + 8)
						g_synth.SetCC(control - 16 + 8, value / float(0x7f));
				}
			}

			break;
		}
		/*
		case MIM_LONGDATA:
		{
		if (!(SysXFlag & 0x80))
		{
		lpMIDIHeader = (LPMIDIHDR)dwParam1;
		ptr = (unsigned char *)(lpMIDIHeader->lpData);
		if (!SysXFlag)
		SysXFlag |= 0x01;
		if (*(ptr + (lpMIDIHeader->dwBytesRecorded - 1)) == 0xF7)
		SysXFlag &= (~0x01);
		bytes = 16;
		while ((lpMIDIHeader->dwBytesRecorded--))
		{
		if (!(--bytes))
		{
		sprintf(&buffer[0], "0x%02X\r\n", *(ptr)++);
		bytes = 16;
		}
		else
		sprintf(&buffer[0], "0x%02X ", *(ptr)++);
		std::cout << buffer;
		}
		if (!SysXFlag)
		std::cout << "\r\n******************************************\r\n";
		midiInAddBuffer(handle, lpMIDIHeader, sizeof(MIDIHDR));
		}

		break;
		}
		*/

		/* Process these messages if you desire */
		/*
		case MIM_OPEN:
		case MIM_CLOSE:
		case MIM_ERROR:
		case MIM_LONGERROR:
		case MIM_MOREDATA:

		break;
		*/
		}
	}



	// static const int BUFFERLEN = 0x10000;
	static const int BUFFERLEN = 2048 * 4;



	typedef void(__stdcall DSIOCALLBACK)(void* parm, float* leftbuf, float* rightbuf, uint numSamples);


	static struct DSData
	{
		IDirectSound *dssd;             // DirectSound instance
		IDirectSoundBuffer *pbuf;       // primary buffer
		IDirectSoundBuffer *sbuf;       // secondary buffer
		DSIOCALLBACK *callback;         // callback function
		void *cbparm;                   // user parameter to callback
		HANDLE tickev;
		HANDLE exitev;
		HANDLE thndl;
		CRITICAL_SECTION crsec;
		float vol;
		uint lastpos;                   // last pos we got
		int bufcnt;                    // filled buffer count
		int ltg;                       // last time got
		float leftMixbuffer[BUFFERLEN / 4];    // 32bit stereo mixing buffer
		float rightMixbuffer[BUFFERLEN / 4];    // 32bit stereo mixing buffer
	} g_dsound;



	static void clamp(void* dest, const float* leftSrc, const float* rightSrc, uint nsamples)
	{
		int16* dests = (int16*)dest;

		for (uint i = 0; i < nsamples; i += 2)
		{
			float l = leftSrc[i / 2] * g_dsound.vol;
			float r = rightSrc[i / 2] * g_dsound.vol;
			if (l >  32600.0f) l = 32600.0f;
			if (l < -32600.0f) l = -32600.0f;
			if (r >  32600.0f) r = 32600.0f;
			if (r < -32600.0f) r = -32600.0f;
			dests[i + 0] = (int16)l;
			dests[i + 1] = (int16)r;
		}
	}



	static DWORD WINAPI threadfunc(void *param)
	{
		BROFILER_THREAD("AudioThread");

		HANDLE handles[2] = { g_dsound.tickev, g_dsound.exitev };

		while (WaitForMultipleObjects(2, handles, FALSE, BUFFERLEN / 3000) != WAIT_OBJECT_0 + 1)
		{
			EnterCriticalSection(&g_dsound.crsec);

			void *buf1, *buf2;
			DWORD len1, len2;

			DWORD curpos;
			int nwrite = 0;
			for (;;)
			{
				HRESULT hr = g_dsound.sbuf->GetCurrentPosition(&curpos, 0);
				if (hr == S_OK)
				{
					curpos &= ~(blockSize - 1);
					if (curpos == g_dsound.lastpos)
						goto done;

					nwrite = curpos - g_dsound.lastpos;
					if (nwrite < 0)
						nwrite += BUFFERLEN;

					hr = g_dsound.sbuf->Lock(g_dsound.lastpos, nwrite, &buf1, &len1, &buf2, &len2, 0);
				}

				if (hr == S_OK)
					break;
				else if (hr == DSERR_BUFFERLOST)
					g_dsound.sbuf->Restore();
				else
					goto done;
			}

			g_dsound.lastpos = curpos;
			g_dsound.bufcnt += nwrite;

			g_dsound.callback(g_dsound.cbparm, g_dsound.leftMixbuffer, g_dsound.rightMixbuffer, nwrite / 4);

			if (buf1)
				clamp(buf1, g_dsound.leftMixbuffer, g_dsound.rightMixbuffer, len1 / 2);
			if (buf2)
				clamp(buf2, g_dsound.leftMixbuffer + len1 / 4, g_dsound.rightMixbuffer + len1 / 4, len2 / 2);

			g_dsound.sbuf->Unlock(buf1, len1, buf2, len2);

		done:
			LeaveCriticalSection(&g_dsound.crsec);
		}

		return 0;
	}



	void __stdcall SoundEngine(void* parm, float* leftbuf, float* rightbuf, uint numSamples)
	{
		PROFILE

		Time startTime = GetTime();

		static std::vector<float> tempLeftBuffer;
		static std::vector<float> tempRightBuffer;

		tempLeftBuffer.resize(numSamples, 0.0);
		tempRightBuffer.resize(numSamples, 0.0);

		g_synth.Step(tempLeftBuffer.data(), tempRightBuffer.data(), numSamples);
		for (uint i = 0; i < numSamples; ++i)
		{
			leftbuf[i] = tempLeftBuffer[i];
			rightbuf[i] = tempRightBuffer[i];
		}

		tempLeftBuffer.clear();
		tempRightBuffer.clear();

		Time endTime = GetTime();
		g_oscilloscope.AddSamples(leftbuf, rightbuf, numSamples, endTime - startTime);
	}



	static void release(IUnknown **pcom)
	{
		if (*pcom)
		{
			(*pcom)->Release();
			*pcom = 0;
		}
	}



	void __stdcall dsSetVolume(float vol)
	{
		g_dsound.vol = vol * 32768.0f;
	}



	void __stdcall dsClose()
	{
		if (g_dsound.thndl)
		{
			SetEvent(g_dsound.exitev);
			WaitForSingleObject(g_dsound.thndl, INFINITE);
		}

		CloseHandle(g_dsound.tickev);
		CloseHandle(g_dsound.exitev);
		CloseHandle(g_dsound.thndl);
		DeleteCriticalSection(&g_dsound.crsec);
		release((IUnknown **)&g_dsound.sbuf);
		release((IUnknown **)&g_dsound.pbuf);
		release((IUnknown **)&g_dsound.dssd);
	}



	uint __stdcall dsInit(DSIOCALLBACK* callback, void* parm, void* hwnd)
	{
		static const WAVEFORMATEX wfxprimary = { WAVE_FORMAT_PCM, 2, sampleRate, sampleRate * 2 * 2, 2 * 2, 16, 0 };
		static const DSBUFFERDESC primdesc = { sizeof(DSBUFFERDESC), DSBCAPS_PRIMARYBUFFER, 0, 0, 0 };
		static const DSBUFFERDESC streamdesc = { sizeof(DSBUFFERDESC), DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_GLOBALFOCUS, BUFFERLEN, 0, (WAVEFORMATEX*)&wfxprimary };

		ZeroMemory(&g_dsound, sizeof(g_dsound));
		g_dsound.callback = callback;
		g_dsound.cbparm = parm;

		void *buf1, *buf2;
		DWORD len1, len2;

		if (DirectSoundCreate(0, &g_dsound.dssd, 0) != S_OK) // create DSound instance
			goto bad;
		if (g_dsound.dssd->SetCooperativeLevel((HWND)hwnd, DSSCL_PRIORITY) != S_OK) // cooperative level
			goto bad;
		if (g_dsound.dssd->CreateSoundBuffer(&primdesc, &g_dsound.pbuf, 0) != S_OK) // primary buffer
			goto bad;
		if (g_dsound.dssd->CreateSoundBuffer(&streamdesc, &g_dsound.sbuf, 0) != S_OK) // secondary buffer
			goto bad;
		if (g_dsound.pbuf->SetFormat(&wfxprimary) != S_OK) // set primary buf format
			goto bad;
		if (g_dsound.sbuf->Lock(0, 0, &buf1, &len1, &buf2, &len2, DSBLOCK_ENTIREBUFFER) != S_OK) // lock secondary buf
			goto bad;

		// clear secondary buffer
		memset(buf1, 0, len1);
		memset(buf2, 0, len2);
		if (g_dsound.sbuf->Unlock(buf1, len1, buf2, len2) != S_OK)
			goto bad;

		g_dsound.bufcnt = -BUFFERLEN;
		g_dsound.ltg = -BUFFERLEN;

		g_dsound.tickev = CreateEvent(0, FALSE, FALSE, 0);
		g_dsound.exitev = CreateEvent(0, FALSE, FALSE, 0);
		InitializeCriticalSection(&g_dsound.crsec);

		if (g_dsound.sbuf->Play(0, 0, DSBPLAY_LOOPING) != S_OK)
			goto bad;

		dsSetVolume(1.0);

		// start sound thread
		g_dsound.thndl = CreateThread(0, 0, threadfunc, 0, 0, &len1);
		SetThreadPriority(g_dsound.thndl, THREAD_PRIORITY_ABOVE_NORMAL);

		return 0;

	bad:
		dsClose();
		return ~0u;
	}




	void Oscilloscope::DrawOscilloscope(const std::array<float, numSamples>& samples, float yOffset)
	{
		//	rate = std::pow(20, g_voice.cc[8]);

		const float smpRate = (1.0f / numSamples) * rate;
		uint sample = 0;
		while (sample < numSamples)
		{
			float x = 0.0f;
			for (; sample < numSamples - 1; ++sample)
			{
				if (samples[sample] < trigger && samples[sample + 1] > trigger)
					break;
			}
			glBegin(GL_LINE_STRIP);
			for (; sample < numSamples; ++sample)
			{
				const float y = samples[sample] * scale + yOffset;
				glVertex2f(x, y);
				x += smpRate;
				if (x > 1.0f)
					break;
			}
			glEnd();
		}
	}


}


void Synth()
{
	BROFILER_THREAD("MainThread");

	ProtoGL protoGL;
	protoGL.Initialize(ProtoGLDesc(1280, 720));
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glEnable(GL_LINE_SMOOTH);
	glEnable(GL_BLEND);

	CameraOrtho2D camera(protoGL.GetCanvas(), CameraOrtho2D::Upward);
	camera.SetCamera(Vector2f(0.5f, 0.5f), 1.15f);

	const uint keyboardPort = 0;
	const uint nanoKorgPort = 4;

	uint numDevices = midiInGetNumDevs();
	for (uint i = 0; i < numDevices; ++i)
	{
		MIDIINCAPS caps;
		midiInGetDevCaps(i, &caps, sizeof(MIDIINCAPS));
		std::wcout << i << " : " << std::wstring(caps.szPname).c_str() << std::endl;
	}

	MMRESULT result;

	result = midiInOpen(
		&keyboardMidi,
		keyboardPort,
		(DWORD_PTR)&MidiCallback,
		0,
		CALLBACK_FUNCTION);
	result = midiInOpen(
		&nanoKorgMidi,
		nanoKorgPort,
		(DWORD_PTR)&MidiCallback,
		0,
		CALLBACK_FUNCTION);

	SysXFlag |= 0x80;
	result = midiInStart(keyboardMidi);
	result = midiInStart(nanoKorgMidi);

	// dsInit(SoundEngine, nullptr, protoGL.GetCanvas()->GetHandle());

	//////////////////////////
		
	const float sampleRate = 44100.0f * 4.0f;
	const float invSmpRate = 1.0f / sampleRate;
	const uint subSamples = 1;
	const float minF0 = 20.0f;
	const float maxF0 = 22050.0f;

	const float minCutoff = 20.0;
	const float maxCutoff = 20000.0;
	const float cutoffExp = g_synth.patch.filter[0].cuttoff;
	const float cutoff = minCutoff * powf(maxCutoff / minCutoff, cutoffExp);

	const float minBandwidth = 0.1;
	const float maxBandwidth = 2.0;
	const float resonance = g_synth.patch.filter[0].resonance;
	const float bandwidth = minBandwidth * powf(maxBandwidth / minBandwidth, 1.0f - resonance);

	musicdsp::BiquadFilter filter0;
	musicdsp::BiquadFilter filter1;
//	filter0.Setup(musicdsp::BiquadFilter::LPF, 1.0f, cutoff, sampleRate, bandwidth);
	filter0.Setup(musicdsp::BiquadFilter::LPF, 1.0f, cutoff, sampleRate, 2.0f);
	filter1.Setup(musicdsp::BiquadFilter::LPF, 1.0f, cutoff, sampleRate, 2.0f);

	//////////////////////////

	std::vector<float> samples;
	samples.resize(sampleRate);

	std::mt19937 rand;
//	std::uniform_real_distribution<float> dist(1.0f, 1.0f);
	std::normal_distribution<float> dist(0.0f, 1.0f);
	for (uint i = 0; i < uint(sampleRate) / 4; ++i)
	{
		samples[i] = dist(rand);
	//	samples[i] = std::sin(2.0f * PI * invSmpRate * 1300.0f * i);
	//	samples[i] = std::fmod(invSmpRate * 1300.0f * i, 1.0f) * 2.0f - 1.0f;

		samples[i] = filter0.Proccess(samples[i]);
		samples[i] = filter1.Proccess(samples[i]);
	}

	auto FFT = [](float* samples, uint count, float f0)
	{
		const float spin = 2.0f * PI * f0;
		const float mult = 1.0f / count;
		float cx = 0.0f;
		float cy = 0.0f;
		for (uint i = 0; i < count; ++i)
		{
			cx += std::cos(spin * i) * samples[i] * mult;
			cy += std::sin(spin * i) * samples[i] * mult;
		}
		return std::sqrt(cx * cx + cy * cy) * 2.0f;
	};

	std::vector<float> xxs;
	std::vector<float> fftRes;
	// for (float f = 0.0; f <= 1.0; f += 1.0f / 1024.0f)
	// for (float f = 0.0; f <= 1.0; f += 1.0f / (maxF0 - minF0))
	for (float f0 = minF0; f0 <= maxF0; f0 += 1.0f)
	{
	//	const float f0 = minF0 * powf(maxF0 / minF0, f);
		const float f = std::log(f0 / minF0) / std::log(maxF0 / minF0);

		const float fft = FFT(samples.data(), samples.size(), f0 * invSmpRate);

		xxs.push_back(f);
		fftRes.push_back(fft);
	}

	//////////////////////////

	while (protoGL.Update())
	{
		BROFILER_FRAME("Frame"); 

		glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
		glClear(GL_COLOR_BUFFER_BIT);

		camera.CommitToGL();

	//	g_oscilloscope.Draw();

		auto MapFreqToX = [=](float f)
		{
			// const float f0 = minF0 * powf(maxF0 / minF0, f);
			return std::log(f / minF0) / std::log(maxF0 / minF0);
			// return MapGainToY(DbToAmp(db));
		};

		auto MapGainToY = [=](float g)
		{
			const float minDb = -36.0f;
			const float maxDb = 36.0f;
			return (minDb - AmpToDb(g)) / (minDb - maxDb);
		};

		auto MapDbToY = [=](float db)
		{
			return MapGainToY(DbToAmp(db));
		};

		glLineWidth(3.0f);
		glColor4ub(192, 0, 0, 255);
		glBegin(GL_LINE_LOOP);
		glVertex2f(0.0f, 0.0f);
		glVertex2f(1.0f, 0.0f);
		glVertex2f(1.0f, 1.0f);
		glVertex2f(0.0f, 1.0f);
		glEnd();

		glLineWidth(1.0f);
		glBegin(GL_LINES);
		const float ctX = std::log(cutoff / minF0) / std::log(maxF0 / minF0);
		glColor4ub(128, 32, 0, 255);
		glVertex2f(0.0f, MapDbToY(-3.0f));
		glVertex2f(1.0f, MapDbToY(-3.0f));
		glVertex2f(0.0f, MapDbToY(-6.0f));
		glVertex2f(1.0f, MapDbToY(-6.0f));
		glColor4ub(192, 128, 0, 255);
		glVertex2f(0.0f, MapDbToY(0.0f));
		glVertex2f(1.0f, MapDbToY(0.0f));
		glVertex2f(0.0f, MapDbToY(-12.0f));
		glVertex2f(1.0f, MapDbToY(-12.0f));
		glVertex2f(0.0f, MapDbToY(-24.0f));
		glVertex2f(1.0f, MapDbToY(-24.0f));

		glVertex2f(MapFreqToX(80.0f), 0.0f);
		glVertex2f(MapFreqToX(80.0f), 1.0f);
		glVertex2f(MapFreqToX(320.0f), 0.0f);
		glVertex2f(MapFreqToX(320.0f), 1.0f);
		glVertex2f(MapFreqToX(1300.0f), 0.0f);
		glVertex2f(MapFreqToX(1300.0f), 1.0f);
		glVertex2f(MapFreqToX(5100.0f), 0.0f);
		glVertex2f(MapFreqToX(5100.0f), 1.0f);
		glVertex2f(MapFreqToX(20000.0f), 0.0f);
		glVertex2f(MapFreqToX(20000.0f), 1.0f);
		glVertex2f(ctX, 0.0f);
		glVertex2f(ctX, 1.0f);

		glEnd();

		glLineWidth(2.0f);
		glColor4ub(32, 192, 255, 255);
		glBegin(GL_LINE_STRIP);
#if 0
		for (float f = 0.0; f <= 1.0; f += 1.0f / 256.0f)
		{
			const float f0 = minF0 * powf(maxF0 / minF0, f);
			
		//	vcv::LadderFilter filter;
		//	filter.cutoff = cutoff;
		//	filter.resonance = bandwidth;

		//	musicdsp::StateFilter filter0;
		//	musicdsp::StateFilter filter1;
		//	filter0.Setup(cutoff, 0.5f + resonance * 5.0f, invSmpRate / subSamples);
		//	filter1.Setup(cutoff, 0.5f + resonance * 5.0f, invSmpRate / subSamples);

			uint numSamples = 0;
			float rmsIn = 0.0f;
			float rmsOut = 0.0f;
			for (float s = 0.0f; s <= 0.175f ; s += invSmpRate)
			{
				for (uint ss = 0; ss < subSamples; ++ss)
				{
					numSamples++;

					const float xIn = std::sin(2 * PI * f0 * (s / subSamples));
					rmsIn += xIn * xIn;

					// const float xOut = filter.Proccess(xIn);

					/*
					filter0.Proccess(xIn);
					for (uint ss = 1; ss < subSamples; ++ss)
					{
						filter1.Proccess(filter0.L);
						filter0.Proccess(filter1.L);
					}
					filter1.Proccess(filter0.L);
					*/

					float xOut = xIn;

					/*
					filter0.Proccess(xOut);
					xOut = filter0.L;
					//	filter1.Proccess(xOut);
					//	xOut = filter1.L;

					// filter.process(xIn, invSmpRate);
					// const float xOut = filter.state[3];
					*/

				//	filter0.Proccess(xOut);
				//	xOut = filter0.L;
				//	filter1.Proccess(xOut);
				//	xOut = filter1.L;

					xOut = filter0.Proccess(xOut);
				//	xOut = filter1.Proccess(xOut);

					rmsOut += xOut * xOut;
				}
			}
			rmsIn = std::sqrt(rmsIn / numSamples);
			rmsOut = std::sqrt(rmsOut / numSamples);

			glVertex2f(f, MapGainToY(rmsOut / rmsIn));
		}
#endif
		for (uint i = 0; i < xxs.size(); ++i)
		{
			glVertex2f(xxs[i], MapGainToY(fftRes[i]));
		}

		glEnd();

		protoGL.Swap();
	}
		
	dsClose();

	result = midiInClose(nanoKorgMidi);
	result = midiInClose(keyboardMidi);
}

#endif
